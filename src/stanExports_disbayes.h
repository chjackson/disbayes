// Generated by rstantools.  Do not edit by hand.

/*
    disbayes is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    disbayes is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with disbayes.  If not, see <http://www.gnu.org/licenses/>.
*/
#ifndef MODELS_HPP
#define MODELS_HPP
#define STAN__SERVICES__COMMAND_HPP
#ifndef USE_STANC3
#define USE_STANC3
#endif
#include <rstan/rstaninc.hpp>
// Code generated by stanc v2.26.1-1-g67504470
#include <stan/model/model_header.hpp>
namespace model_disbayes_namespace {
inline void validate_positive_index(const char* var_name, const char* expr,
                                    int val) {
  if (val < 1) {
    std::stringstream msg;
    msg << "Found dimension size less than one in simplex declaration"
        << "; variable=" << var_name << "; dimension size expression=" << expr
        << "; expression value=" << val;
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}
inline void validate_unit_vector_index(const char* var_name, const char* expr,
                                       int val) {
  if (val <= 1) {
    std::stringstream msg;
    if (val == 1) {
      msg << "Found dimension size one in unit vector declaration."
          << " One-dimensional unit vector is discrete"
          << " but the target distribution must be continuous."
          << " variable=" << var_name << "; dimension size expression=" << expr;
    } else {
      msg << "Found dimension size less than one in unit vector declaration"
          << "; variable=" << var_name << "; dimension size expression=" << expr
          << "; expression value=" << val;
    }
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}
using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math;
using stan::math::pow; 
stan::math::profile_map profiles__;
static int current_statement__= 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'string', line 152, column 2 to column 47)",
                                                      " (in 'string', line 153, column 2 to column 45)",
                                                      " (in 'string', line 154, column 2 to column 89)",
                                                      " (in 'string', line 155, column 2 to column 40)",
                                                      " (in 'string', line 156, column 2 to column 55)",
                                                      " (in 'string', line 157, column 2 to column 58)",
                                                      " (in 'string', line 158, column 2 to column 32)",
                                                      " (in 'string', line 159, column 2 to column 58)",
                                                      " (in 'string', line 160, column 2 to column 32)",
                                                      " (in 'string', line 161, column 2 to column 46)",
                                                      " (in 'string', line 163, column 2 to column 30)",
                                                      " (in 'string', line 164, column 2 to column 42)",
                                                      " (in 'string', line 167, column 2 to column 27)",
                                                      " (in 'string', line 168, column 2 to column 42)",
                                                      " (in 'string', line 169, column 2 to column 34)",
                                                      " (in 'string', line 170, column 2 to column 47)",
                                                      " (in 'string', line 171, column 2 to column 28)",
                                                      " (in 'string', line 172, column 2 to column 51)",
                                                      " (in 'string', line 173, column 2 to column 40)",
                                                      " (in 'string', line 175, column 2 to column 54)",
                                                      " (in 'string', line 176, column 2 to column 20)",
                                                      " (in 'string', line 177, column 2 to column 33)",
                                                      " (in 'string', line 178, column 2 to column 40)",
                                                      " (in 'string', line 179, column 2 to column 32)",
                                                      " (in 'string', line 180, column 2 to column 46)",
                                                      " (in 'string', line 181, column 2 to column 51)",
                                                      " (in 'string', line 182, column 2 to column 63)",
                                                      " (in 'string', line 183, column 2 to column 30)",
                                                      " (in 'string', line 184, column 2 to column 31)",
                                                      " (in 'string', line 185, column 2 to column 31)",
                                                      " (in 'string', line 186, column 71 to column 100)",
                                                      " (in 'string', line 186, column 33 to column 65)",
                                                      " (in 'string', line 186, column 2 to column 100)",
                                                      " (in 'string', line 187, column 75 to column 106)",
                                                      " (in 'string', line 187, column 35 to column 69)",
                                                      " (in 'string', line 187, column 2 to column 106)",
                                                      " (in 'string', line 188, column 75 to column 106)",
                                                      " (in 'string', line 188, column 35 to column 69)",
                                                      " (in 'string', line 188, column 2 to column 106)",
                                                      " (in 'string', line 192, column 56 to column 80)",
                                                      " (in 'string', line 192, column 18 to column 50)",
                                                      " (in 'string', line 192, column 2 to column 80)",
                                                      " (in 'string', line 194, column 4 to column 60)",
                                                      " (in 'string', line 193, column 17 to line 195, column 3)",
                                                      " (in 'string', line 193, column 2 to line 195, column 3)",
                                                      " (in 'string', line 203, column 9 to column 35)",
                                                      " (in 'string', line 202, column 9 to column 23)",
                                                      " (in 'string', line 201, column 25 to column 47)",
                                                      " (in 'string', line 201, column 9 to line 202, column 23)",
                                                      " (in 'string', line 199, column 1 to column 21)",
                                                      " (in 'string', line 198, column 6 to line 199, column 21)",
                                                      " (in 'string', line 197, column 19 to line 200, column 5)",
                                                      " (in 'string', line 197, column 4 to line 202, column 23)",
                                                      " (in 'string', line 196, column 17 to line 203, column 3)",
                                                      " (in 'string', line 196, column 2 to line 203, column 35)",
                                                      " (in 'string', line 209, column 9 to column 28)",
                                                      " (in 'string', line 208, column 6 to column 35)",
                                                      " (in 'string', line 207, column 4 to line 209, column 28)",
                                                      " (in 'string', line 206, column 21 to line 210, column 3)",
                                                      " (in 'string', line 206, column 2 to line 210, column 3)",
                                                      " (in 'string', line 224, column 39 to column 51)",
                                                      " (in 'string', line 224, column 16 to column 33)",
                                                      " (in 'string', line 224, column 1 to column 51)",
                                                      " (in 'string', line 223, column 9 to line 225, column 3)",
                                                      " (in 'string', line 215, column 8 to column 26)",
                                                      " (in 'string', line 214, column 28 to line 216, column 7)",
                                                      " (in 'string', line 214, column 6 to line 216, column 7)",
                                                      " (in 'string', line 219, column 13 to column 39)",
                                                      " (in 'string', line 218, column 1 to column 19)",
                                                      " (in 'string', line 217, column 20 to line 219, column 7)",
                                                      " (in 'string', line 217, column 6 to line 219, column 39)",
                                                      " (in 'string', line 221, column 1 to column 26)",
                                                      " (in 'string', line 220, column 27 to line 222, column 7)",
                                                      " (in 'string', line 220, column 6 to line 222, column 7)",
                                                      " (in 'string', line 212, column 21 to line 223, column 3)",
                                                      " (in 'string', line 212, column 2 to line 225, column 3)",
                                                      " (in 'string', line 252, column 6 to column 29)",
                                                      " (in 'string', line 253, column 6 to column 29)",
                                                      " (in 'string', line 254, column 6 to column 29)",
                                                      " (in 'string', line 251, column 22 to line 255, column 5)",
                                                      " (in 'string', line 251, column 4 to line 255, column 5)",
                                                      " (in 'string', line 250, column 9 to line 256, column 3)",
                                                      " (in 'string', line 228, column 4 to column 21)",
                                                      " (in 'string', line 230, column 6 to column 44)",
                                                      " (in 'string', line 229, column 20 to line 231, column 5)",
                                                      " (in 'string', line 229, column 4 to line 231, column 5)",
                                                      " (in 'string', line 235, column 3 to column 47)",
                                                      " (in 'string', line 234, column 18 to line 236, column 2)",
                                                      " (in 'string', line 234, column 1 to line 236, column 2)",
                                                      " (in 'string', line 233, column 22 to line 237, column 7)",
                                                      " (in 'string', line 233, column 6 to line 237, column 7)",
                                                      " (in 'string', line 240, column 1 to column 29)",
                                                      " (in 'string', line 241, column 1 to column 29)",
                                                      " (in 'string', line 242, column 1 to column 29)",
                                                      " (in 'string', line 246, column 3 to column 52)",
                                                      " (in 'string', line 245, column 22 to line 247, column 2)",
                                                      " (in 'string', line 245, column 1 to line 247, column 2)",
                                                      " (in 'string', line 239, column 23 to line 248, column 7)",
                                                      " (in 'string', line 239, column 6 to line 248, column 7)",
                                                      " (in 'string', line 232, column 22 to line 249, column 5)",
                                                      " (in 'string', line 232, column 4 to line 249, column 5)",
                                                      " (in 'string', line 226, column 13 to line 250, column 3)",
                                                      " (in 'string', line 226, column 2 to line 256, column 3)",
                                                      " (in 'string', line 279, column 1 to column 42)",
                                                      " (in 'string', line 280, column 1 to column 45)",
                                                      " (in 'string', line 282, column 3 to column 83)",
                                                      " (in 'string', line 281, column 1 to line 282, column 83)",
                                                      " (in 'string', line 283, column 1 to column 32)",
                                                      " (in 'string', line 284, column 1 to column 30)",
                                                      " (in 'string', line 286, column 3 to column 70)",
                                                      " (in 'string', line 287, column 3 to column 35)",
                                                      " (in 'string', line 289, column 5 to column 26)",
                                                      " (in 'string', line 288, column 3 to line 289, column 26)",
                                                      " (in 'string', line 285, column 11 to line 290, column 2)",
                                                      " (in 'string', line 285, column 1 to line 290, column 2)",
                                                      " (in 'string', line 278, column 24 to line 291, column 7)",
                                                      " (in 'string', line 278, column 6 to line 291, column 7)",
                                                      " (in 'string', line 277, column 11 to line 292, column 5)",
                                                      " (in 'string', line 261, column 3 to column 9)",
                                                      " (in 'string', line 263, column 5 to column 21)",
                                                      " (in 'string', line 264, column 5 to column 69)",
                                                      " (in 'string', line 265, column 5 to column 48)",
                                                      " (in 'string', line 266, column 5 to column 40)",
                                                      " (in 'string', line 262, column 17 to line 267, column 4)",
                                                      " (in 'string', line 262, column 3 to line 267, column 4)",
                                                      " (in 'string', line 260, column 12 to line 268, column 2)",
                                                      " (in 'string', line 260, column 1 to line 268, column 2)",
                                                      " (in 'string', line 270, column 1 to column 56)",
                                                      " (in 'string', line 271, column 1 to column 45)",
                                                      " (in 'string', line 272, column 1 to line 273, column 59)",
                                                      " (in 'string', line 274, column 11 to column 78)",
                                                      " (in 'string', line 274, column 1 to column 78)",
                                                      " (in 'string', line 275, column 1 to column 33)",
                                                      " (in 'string', line 259, column 24 to line 276, column 7)",
                                                      " (in 'string', line 259, column 6 to line 276, column 7)",
                                                      " (in 'string', line 258, column 15 to line 277, column 5)",
                                                      " (in 'string', line 258, column 4 to line 292, column 5)",
                                                      " (in 'string', line 294, column 4 to column 44)",
                                                      " (in 'string', line 257, column 19 to line 295, column 3)",
                                                      " (in 'string', line 257, column 2 to line 295, column 3)",
                                                      " (in 'string', line 367, column 2 to column 23)",
                                                      " (in 'string', line 368, column 2 to column 35)",
                                                      " (in 'string', line 369, column 2 to column 37)",
                                                      " (in 'string', line 370, column 2 to column 32)",
                                                      " (in 'string', line 371, column 2 to column 73)",
                                                      " (in 'string', line 373, column 6 to column 76)",
                                                      " (in 'string', line 375, column 1 to column 67)",
                                                      " (in 'string', line 374, column 6 to line 375, column 67)",
                                                      " (in 'string', line 377, column 1 to column 71)",
                                                      " (in 'string', line 376, column 6 to line 377, column 71)",
                                                      " (in 'string', line 379, column 3 to column 69)",
                                                      " (in 'string', line 378, column 6 to line 379, column 69)",
                                                      " (in 'string', line 372, column 20 to line 380, column 3)",
                                                      " (in 'string', line 372, column 2 to line 380, column 3)",
                                                      " (in 'string', line 381, column 2 to column 84)",
                                                      " (in 'string', line 298, column 2 to column 45)",
                                                      " (in 'string', line 299, column 2 to column 62)",
                                                      " (in 'string', line 300, column 2 to column 66)",
                                                      " (in 'string', line 302, column 4 to column 44)",
                                                      " (in 'string', line 301, column 17 to line 303, column 3)",
                                                      " (in 'string', line 301, column 2 to line 303, column 3)",
                                                      " (in 'string', line 319, column 6 to column 50)",
                                                      " (in 'string', line 318, column 21 to line 320, column 5)",
                                                      " (in 'string', line 318, column 4 to line 320, column 5)",
                                                      " (in 'string', line 317, column 7 to line 321, column 3)",
                                                      " (in 'string', line 308, column 1 to column 36)",
                                                      " (in 'string', line 307, column 25 to line 309, column 7)",
                                                      " (in 'string', line 307, column 6 to line 309, column 7)",
                                                      " (in 'string', line 311, column 1 to column 26)",
                                                      " (in 'string', line 310, column 24 to line 312, column 7)",
                                                      " (in 'string', line 310, column 6 to line 312, column 7)",
                                                      " (in 'string', line 306, column 19 to line 313, column 5)",
                                                      " (in 'string', line 306, column 4 to line 313, column 5)",
                                                      " (in 'string', line 315, column 6 to column 41)",
                                                      " (in 'string', line 314, column 4 to line 315, column 41)",
                                                      " (in 'string', line 305, column 18 to line 316, column 3)",
                                                      " (in 'string', line 305, column 2 to line 321, column 3)",
                                                      " (in 'string', line 323, column 4 to column 48)",
                                                      " (in 'string', line 322, column 21 to line 324, column 3)",
                                                      " (in 'string', line 322, column 2 to line 324, column 3)",
                                                      " (in 'string', line 337, column 6 to column 53)",
                                                      " (in 'string', line 336, column 21 to line 338, column 5)",
                                                      " (in 'string', line 336, column 4 to line 338, column 5)",
                                                      " (in 'string', line 335, column 7 to line 339, column 3)",
                                                      " (in 'string', line 327, column 6 to column 46)",
                                                      " (in 'string', line 326, column 23 to line 328, column 5)",
                                                      " (in 'string', line 326, column 4 to line 328, column 5)",
                                                      " (in 'string', line 330, column 6 to column 35)",
                                                      " (in 'string', line 329, column 22 to line 331, column 5)",
                                                      " (in 'string', line 329, column 4 to line 331, column 5)",
                                                      " (in 'string', line 333, column 6 to column 42)",
                                                      " (in 'string', line 332, column 4 to line 333, column 42)",
                                                      " (in 'string', line 325, column 19 to line 334, column 3)",
                                                      " (in 'string', line 325, column 2 to line 339, column 3)",
                                                      " (in 'string', line 354, column 1 to column 48)",
                                                      " (in 'string', line 353, column 23 to line 355, column 7)",
                                                      " (in 'string', line 353, column 6 to line 355, column 7)",
                                                      " (in 'string', line 352, column 9 to line 356, column 5)",
                                                      " (in 'string', line 351, column 26 to column 73)",
                                                      " (in 'string', line 351, column 11 to line 356, column 5)",
                                                      " (in 'string', line 344, column 1 to column 41)",
                                                      " (in 'string', line 343, column 25 to line 345, column 7)",
                                                      " (in 'string', line 343, column 6 to line 345, column 7)",
                                                      " (in 'string', line 347, column 1 to column 30)",
                                                      " (in 'string', line 346, column 24 to line 348, column 7)",
                                                      " (in 'string', line 346, column 6 to line 348, column 7)",
                                                      " (in 'string', line 350, column 1 to column 37)",
                                                      " (in 'string', line 349, column 6 to line 350, column 37)",
                                                      " (in 'string', line 342, column 21 to line 351, column 5)",
                                                      " (in 'string', line 342, column 4 to line 356, column 5)",
                                                      " (in 'string', line 341, column 17 to line 357, column 3)",
                                                      " (in 'string', line 341, column 2 to line 357, column 3)",
                                                      " (in 'string', line 360, column 4 to column 29)",
                                                      " (in 'string', line 359, column 15 to line 361, column 3)",
                                                      " (in 'string', line 359, column 2 to line 361, column 3)",
                                                      " (in 'string', line 363, column 4 to column 28)",
                                                      " (in 'string', line 362, column 16 to line 364, column 3)",
                                                      " (in 'string', line 362, column 2 to line 364, column 3)",
                                                      " (in 'string', line 103, column 2 to column 19)",
                                                      " (in 'string', line 104, column 2 to column 20)",
                                                      " (in 'string', line 105, column 2 to column 16)",
                                                      " (in 'string', line 106, column 2 to column 17)",
                                                      " (in 'string', line 107, column 2 to column 17)",
                                                      " (in 'string', line 108, column 2 to column 16)",
                                                      " (in 'string', line 109, column 2 to column 12)",
                                                      " (in 'string', line 110, column 2 to column 16)",
                                                      " (in 'string', line 111, column 2 to column 20)",
                                                      " (in 'string', line 112, column 2 to column 21)",
                                                      " (in 'string', line 113, column 24 to column 28)",
                                                      " (in 'string', line 113, column 2 to column 30)",
                                                      " (in 'string', line 114, column 26 to column 30)",
                                                      " (in 'string', line 114, column 2 to column 32)",
                                                      " (in 'string', line 115, column 24 to column 28)",
                                                      " (in 'string', line 115, column 2 to column 30)",
                                                      " (in 'string', line 116, column 26 to column 30)",
                                                      " (in 'string', line 116, column 2 to column 32)",
                                                      " (in 'string', line 117, column 23 to column 27)",
                                                      " (in 'string', line 117, column 2 to column 29)",
                                                      " (in 'string', line 118, column 25 to column 29)",
                                                      " (in 'string', line 118, column 2 to column 31)",
                                                      " (in 'string', line 119, column 23 to column 27)",
                                                      " (in 'string', line 119, column 2 to column 29)",
                                                      " (in 'string', line 120, column 25 to column 29)",
                                                      " (in 'string', line 120, column 2 to column 31)",
                                                      " (in 'string', line 121, column 2 to column 19)",
                                                      " (in 'string', line 124, column 2 to column 17)",
                                                      " (in 'string', line 125, column 9 to column 13)",
                                                      " (in 'string', line 125, column 14 to column 15)",
                                                      " (in 'string', line 125, column 2 to column 19)",
                                                      " (in 'string', line 126, column 2 to column 26)",
                                                      " (in 'string', line 128, column 2 to column 20)",
                                                      " (in 'string', line 129, column 2 to column 15)",
                                                      " (in 'string', line 130, column 2 to column 16)",
                                                      " (in 'string', line 131, column 2 to column 12)",
                                                      " (in 'string', line 133, column 2 to column 18)",
                                                      " (in 'string', line 134, column 2 to column 19)",
                                                      " (in 'string', line 138, column 18 to column 22)",
                                                      " (in 'string', line 138, column 23 to column 26)",
                                                      " (in 'string', line 138, column 2 to column 38)",
                                                      " (in 'string', line 139, column 18 to column 22)",
                                                      " (in 'string', line 139, column 23 to column 26)",
                                                      " (in 'string', line 139, column 2 to column 37)",
                                                      " (in 'string', line 140, column 2 to column 29)",
                                                      " (in 'string', line 141, column 2 to column 28)",
                                                      " (in 'string', line 142, column 2 to column 29)",
                                                      " (in 'string', line 144, column 2 to column 18)",
                                                      " (in 'string', line 145, column 2 to column 19)",
                                                      " (in 'string', line 146, column 2 to column 19)",
                                                      " (in 'string', line 147, column 2 to column 32)",
                                                      " (in 'string', line 148, column 2 to column 33)",
                                                      " (in 'string', line 149, column 2 to column 33)",
                                                      " (in 'string', line 152, column 18 to column 37)",
                                                      " (in 'string', line 153, column 18 to column 36)",
                                                      " (in 'string', line 154, column 18 to column 79)",
                                                      " (in 'string', line 155, column 9 to column 33)",
                                                      " (in 'string', line 156, column 18 to column 43)",
                                                      " (in 'string', line 157, column 18 to column 45)",
                                                      " (in 'string', line 158, column 9 to column 21)",
                                                      " (in 'string', line 159, column 18 to column 45)",
                                                      " (in 'string', line 160, column 9 to column 21)",
                                                      " (in 'string', line 161, column 26 to column 35)",
                                                      " (in 'string', line 163, column 9 to column 17)",
                                                      " (in 'string', line 164, column 18 to column 33)",
                                                      " (in 'string', line 167, column 18 to column 22)",
                                                      " (in 'string', line 168, column 18 to column 36)",
                                                      " (in 'string', line 169, column 18 to column 22)",
                                                      " (in 'string', line 169, column 23 to column 28)",
                                                      " (in 'string', line 170, column 26 to column 30)",
                                                      " (in 'string', line 170, column 31 to column 36)",
                                                      " (in 'string', line 171, column 18 to column 22)",
                                                      " (in 'string', line 172, column 26 to column 40)",
                                                      " (in 'string', line 173, column 26 to column 30)",
                                                      " (in 'string', line 175, column 28 to column 46)",
                                                      " (in 'string', line 175, column 47 to column 52)",
                                                      " (in 'string', line 178, column 18 to column 22)",
                                                      " (in 'string', line 178, column 23 to column 28)",
                                                      " (in 'string', line 179, column 26 to column 30)",
                                                      " (in 'string', line 180, column 18 to column 28)",
                                                      " (in 'string', line 180, column 29 to column 38)",
                                                      " (in 'string', line 181, column 23 to column 33)",
                                                      " (in 'string', line 181, column 34 to column 43)",
                                                      " (in 'string', line 181, column 44 to column 49)",
                                                      " (in 'string', line 182, column 31 to column 45)",
                                                      " (in 'string', line 182, column 46 to column 55)",
                                                      " (in 'string', line 182, column 56 to column 61)",
                                                      " (in 'string', line 367, column 9 to column 13)",
                                                      " (in 'string', line 368, column 9 to column 26)",
                                                      " (in 'string', line 369, column 9 to column 27)",
                                                      " (in 'string', line 370, column 9 to column 23)",
                                                      " (in 'string', line 371, column 9 to column 60)",
                                                      " (in 'string', line 11, column 4 to column 23)",
                                                      " (in 'string', line 12, column 4 to column 61)",
                                                      " (in 'string', line 13, column 4 to column 31)",
                                                      " (in 'string', line 14, column 4 to column 31)",
                                                      " (in 'string', line 15, column 4 to column 18)",
                                                      " (in 'string', line 16, column 4 to column 57)",
                                                      " (in 'string', line 17, column 4 to column 23)",
                                                      " (in 'string', line 18, column 4 to column 15)",
                                                      " (in 'string', line 20, column 4 to column 25)",
                                                      " (in 'string', line 21, column 4 to column 54)",
                                                      " (in 'string', line 22, column 4 to column 15)",
                                                      " (in 'string', line 24, column 4 to column 44)",
                                                      " (in 'string', line 25, column 4 to column 51)",
                                                      " (in 'string', line 26, column 4 to column 15)",
                                                      " (in 'string', line 27, column 4 to column 13)",
                                                      " (in 'string', line 10, column 50 to line 28, column 3)",
                                                      " (in 'string', line 31, column 4 to column 19)",
                                                      " (in 'string', line 32, column 4 to column 38)",
                                                      " (in 'string', line 33, column 4 to column 31)",
                                                      " (in 'string', line 34, column 4 to column 31)",
                                                      " (in 'string', line 35, column 4 to column 18)",
                                                      " (in 'string', line 36, column 4 to column 53)",
                                                      " (in 'string', line 37, column 4 to column 15)",
                                                      " (in 'string', line 38, column 4 to column 15)",
                                                      " (in 'string', line 40, column 4 to column 25)",
                                                      " (in 'string', line 41, column 4 to column 50)",
                                                      " (in 'string', line 42, column 4 to column 15)",
                                                      " (in 'string', line 44, column 4 to column 44)",
                                                      " (in 'string', line 45, column 4 to column 51)",
                                                      " (in 'string', line 46, column 4 to column 15)",
                                                      " (in 'string', line 47, column 4 to column 13)",
                                                      " (in 'string', line 30, column 47 to line 48, column 3)",
                                                      " (in 'string', line 51, column 4 to column 18)",
                                                      " (in 'string', line 52, column 4 to column 21)",
                                                      " (in 'string', line 53, column 4 to column 23)",
                                                      " (in 'string', line 54, column 4 to column 38)",
                                                      " (in 'string', line 56, column 4 to column 15)",
                                                      " (in 'string', line 57, column 4 to column 21)",
                                                      " (in 'string', line 58, column 4 to column 25)",
                                                      " (in 'string', line 60, column 4 to column 15)",
                                                      " (in 'string', line 61, column 4 to column 15)",
                                                      " (in 'string', line 62, column 4 to column 15)",
                                                      " (in 'string', line 63, column 4 to column 13)",
                                                      " (in 'string', line 50, column 38 to line 64, column 3)",
                                                      " (in 'string', line 67, column 6 to column 21)",
                                                      " (in 'string', line 70, column 3 to column 20)",
                                                      " (in 'string', line 71, column 19 to column 31)",
                                                      " (in 'string', line 71, column 3 to column 31)",
                                                      " (in 'string', line 72, column 19 to column 31)",
                                                      " (in 'string', line 72, column 3 to column 31)",
                                                      " (in 'string', line 69, column 16 to line 73, column 2)",
                                                      " (in 'string', line 69, column 1 to line 73, column 2)",
                                                      " (in 'string', line 68, column 21 to line 74, column 7)",
                                                      " (in 'string', line 68, column 6 to line 74, column 7)",
                                                      " (in 'string', line 75, column 6 to column 16)",
                                                      " (in 'string', line 66, column 29 to line 76, column 5)",
                                                      " (in 'string', line 79, column 4 to column 18)",
                                                      " (in 'string', line 86, column 1 to column 32)",
                                                      " (in 'string', line 84, column 1 to column 28)",
                                                      " (in 'string', line 83, column 6 to line 86, column 32)",
                                                      " (in 'string', line 82, column 9 to line 87, column 5)",
                                                      " (in 'string', line 81, column 6 to column 35)",
                                                      " (in 'string', line 80, column 4 to line 87, column 5)",
                                                      " (in 'string', line 88, column 4 to column 23)",
                                                      " (in 'string', line 78, column 45 to line 89, column 3)",
                                                      " (in 'string', line 92, column 4 to column 13)",
                                                      " (in 'string', line 97, column 13 to column 21)",
                                                      " (in 'string', line 97, column 11 to column 23)",
                                                      " (in 'string', line 96, column 6 to column 32)",
                                                      " (in 'string', line 95, column 23 to line 97, column 5)",
                                                      " (in 'string', line 95, column 11 to line 97, column 23)",
                                                      " (in 'string', line 94, column 6 to column 36)",
                                                      " (in 'string', line 93, column 16 to line 95, column 5)",
                                                      " (in 'string', line 93, column 4 to line 97, column 23)",
                                                      " (in 'string', line 98, column 4 to column 13)",
                                                      " (in 'string', line 91, column 25 to line 99, column 3)"};
template <typename T0__, typename T1__, typename T2__>
Eigen::Matrix<stan::promote_args_t<T0__, T1__,
T2__>, -1, -1>
trans_probs_rem(const T0__& i, const T1__& f, const T2__& r,
                std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T1__, T2__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    local_scalar_t__ l;
    l = DUMMY_VAR__;
    
    current_statement__ = 311;
    l = ((i + r) + f);
    local_scalar_t__ q;
    q = DUMMY_VAR__;
    
    current_statement__ = 312;
    q = stan::math::sqrt(
          ((((((i * i) + ((2 * i) * r)) - ((2 * i) * f)) + (r * r)) +
             ((2 * f) * r)) + (f * f)));
    local_scalar_t__ w;
    w = DUMMY_VAR__;
    
    current_statement__ = 313;
    w = stan::math::exp((-(l + q) / 2));
    local_scalar_t__ v;
    v = DUMMY_VAR__;
    
    current_statement__ = 314;
    v = stan::math::exp((-(l - q) / 2));
    Eigen::Matrix<local_scalar_t__, -1, -1> P;
    P = Eigen::Matrix<local_scalar_t__, -1, -1>(3, 3);
    stan::math::fill(P, DUMMY_VAR__);
    
    current_statement__ = 316;
    assign(P,
      cons_list(index_uni(1), cons_list(index_uni(1), nil_index_list())),
      (((((2 * (v - w)) * (f + r)) + (v * (q - l))) + (w * (q + l))) /
        (2 * q)), "assigning variable P");
    current_statement__ = 317;
    assign(P,
      cons_list(index_uni(2), cons_list(index_uni(1), nil_index_list())),
      (((v - w) * r) / q), "assigning variable P");
    current_statement__ = 318;
    assign(P,
      cons_list(index_uni(3), cons_list(index_uni(1), nil_index_list())), 0,
      "assigning variable P");
    current_statement__ = 319;
    assign(P,
      cons_list(index_uni(1), cons_list(index_uni(2), nil_index_list())),
      ((i * (v - w)) / q), "assigning variable P");
    current_statement__ = 320;
    assign(P,
      cons_list(index_uni(2), cons_list(index_uni(2), nil_index_list())),
      (-((((2 * (f + r)) - l) * (v - w)) - (q * (v + w))) / (2 * q)),
      "assigning variable P");
    current_statement__ = 321;
    assign(P,
      cons_list(index_uni(3), cons_list(index_uni(2), nil_index_list())), 0,
      "assigning variable P");
    current_statement__ = 322;
    assign(P,
      cons_list(index_uni(1), cons_list(index_uni(3), nil_index_list())),
      ((((-l * (v - w)) - (q * (v + w))) / (2 * q)) + 1),
      "assigning variable P");
    current_statement__ = 323;
    assign(P,
      cons_list(index_uni(2), cons_list(index_uni(3), nil_index_list())),
      (((((v - w) * ((2 * f) - l)) - (q * (v + w))) / (2 * q)) + 1),
      "assigning variable P");
    current_statement__ = 324;
    assign(P,
      cons_list(index_uni(3), cons_list(index_uni(3), nil_index_list())), 1,
      "assigning variable P");
    current_statement__ = 325;
    return P;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct trans_probs_rem_functor__ {
template <typename T0__, typename T1__, typename T2__>
Eigen::Matrix<stan::promote_args_t<T0__, T1__,
T2__>, -1, -1>
operator()(const T0__& i, const T1__& f, const T2__& r,
           std::ostream* pstream__)  const 
{
return trans_probs_rem(i, f, r, pstream__);
}
};
template <typename T0__, typename T1__>
Eigen::Matrix<stan::promote_args_t<T0__,
T1__>, -1, -1>
trans_probs_norem_if(const T0__& i, const T1__& f, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T1__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    local_scalar_t__ l;
    l = DUMMY_VAR__;
    
    current_statement__ = 327;
    l = (i + f);
    local_scalar_t__ q;
    q = DUMMY_VAR__;
    
    current_statement__ = 328;
    q = stan::math::sqrt((((i * i) - ((2 * i) * f)) + (f * f)));
    local_scalar_t__ w;
    w = DUMMY_VAR__;
    
    current_statement__ = 329;
    w = stan::math::exp((-(l + q) / 2));
    local_scalar_t__ v;
    v = DUMMY_VAR__;
    
    current_statement__ = 330;
    v = stan::math::exp((-(l - q) / 2));
    Eigen::Matrix<local_scalar_t__, -1, -1> P;
    P = Eigen::Matrix<local_scalar_t__, -1, -1>(3, 3);
    stan::math::fill(P, DUMMY_VAR__);
    
    current_statement__ = 332;
    assign(P,
      cons_list(index_uni(1), cons_list(index_uni(1), nil_index_list())),
      (((((2 * (v - w)) * f) + (v * (q - l))) + (w * (q + l))) / (2 * q)),
      "assigning variable P");
    current_statement__ = 333;
    assign(P,
      cons_list(index_uni(2), cons_list(index_uni(1), nil_index_list())), 0,
      "assigning variable P");
    current_statement__ = 334;
    assign(P,
      cons_list(index_uni(3), cons_list(index_uni(1), nil_index_list())), 0,
      "assigning variable P");
    current_statement__ = 335;
    assign(P,
      cons_list(index_uni(1), cons_list(index_uni(2), nil_index_list())),
      ((i * (v - w)) / q), "assigning variable P");
    current_statement__ = 336;
    assign(P,
      cons_list(index_uni(2), cons_list(index_uni(2), nil_index_list())),
      (-((((2 * f) - l) * (v - w)) - (q * (v + w))) / (2 * q)),
      "assigning variable P");
    current_statement__ = 337;
    assign(P,
      cons_list(index_uni(3), cons_list(index_uni(2), nil_index_list())), 0,
      "assigning variable P");
    current_statement__ = 338;
    assign(P,
      cons_list(index_uni(1), cons_list(index_uni(3), nil_index_list())),
      ((((-l * (v - w)) - (q * (v + w))) / (2 * q)) + 1),
      "assigning variable P");
    current_statement__ = 339;
    assign(P,
      cons_list(index_uni(2), cons_list(index_uni(3), nil_index_list())),
      (((((v - w) * ((2 * f) - l)) - (q * (v + w))) / (2 * q)) + 1),
      "assigning variable P");
    current_statement__ = 340;
    assign(P,
      cons_list(index_uni(3), cons_list(index_uni(3), nil_index_list())), 1,
      "assigning variable P");
    current_statement__ = 341;
    return P;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct trans_probs_norem_if_functor__ {
template <typename T0__, typename T1__>
Eigen::Matrix<stan::promote_args_t<T0__,
T1__>, -1, -1>
operator()(const T0__& i, const T1__& f, std::ostream* pstream__)  const 
{
return trans_probs_norem_if(i, f, pstream__);
}
};
template <typename T0__>
Eigen::Matrix<stan::promote_args_t<T0__>, -1, -1>
trans_probs_norem_i(const T0__& i, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    Eigen::Matrix<local_scalar_t__, -1, -1> P;
    P = Eigen::Matrix<local_scalar_t__, -1, -1>(3, 3);
    stan::math::fill(P, DUMMY_VAR__);
    
    current_statement__ = 344;
    assign(P,
      cons_list(index_uni(1), cons_list(index_uni(1), nil_index_list())),
      stan::math::exp(-i), "assigning variable P");
    current_statement__ = 345;
    assign(P,
      cons_list(index_uni(1), cons_list(index_uni(2), nil_index_list())),
      (i * stan::math::exp(-i)), "assigning variable P");
    current_statement__ = 346;
    assign(P,
      cons_list(index_uni(1), cons_list(index_uni(3), nil_index_list())),
      ((-stan::math::exp(-i) + 1) - (i * stan::math::exp(-i))),
      "assigning variable P");
    current_statement__ = 347;
    assign(P,
      cons_list(index_uni(2), cons_list(index_uni(1), nil_index_list())), 0,
      "assigning variable P");
    current_statement__ = 348;
    assign(P,
      cons_list(index_uni(2), cons_list(index_uni(2), nil_index_list())),
      stan::math::exp(-i), "assigning variable P");
    current_statement__ = 349;
    assign(P,
      cons_list(index_uni(2), cons_list(index_uni(3), nil_index_list())),
      (1 - stan::math::exp(-i)), "assigning variable P");
    current_statement__ = 350;
    assign(P,
      cons_list(index_uni(3), cons_list(index_uni(1), nil_index_list())), 0,
      "assigning variable P");
    current_statement__ = 351;
    assign(P,
      cons_list(index_uni(3), cons_list(index_uni(2), nil_index_list())), 0,
      "assigning variable P");
    current_statement__ = 352;
    assign(P,
      cons_list(index_uni(3), cons_list(index_uni(3), nil_index_list())), 1,
      "assigning variable P");
    current_statement__ = 353;
    return P;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct trans_probs_norem_i_functor__ {
template <typename T0__>
Eigen::Matrix<stan::promote_args_t<T0__>, -1, -1>
operator()(const T0__& i, std::ostream* pstream__)  const 
{
return trans_probs_norem_i(i, pstream__);
}
};
template <typename T0__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>>, -1, -1>
defuzz_P(const T0__& P_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T0__>>;
  const auto& P = to_ref(P_arg__);
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    Eigen::Matrix<local_scalar_t__, -1, -1> Pr;
    Pr = Eigen::Matrix<local_scalar_t__, -1, -1>(3, 3);
    stan::math::fill(Pr, DUMMY_VAR__);
    
    current_statement__ = 364;
    for (int r = 1; r <= 3; ++r) {
      current_statement__ = 362;
      for (int s = 1; s <= 3; ++s) {
        current_statement__ = 356;
        assign(Pr,
          cons_list(index_uni(r), cons_list(index_uni(s), nil_index_list())),
          rvalue(P,
            cons_list(index_uni(r),
              cons_list(index_uni(s), nil_index_list())), "P"),
          "assigning variable Pr");
        current_statement__ = 358;
        if (logical_lt(
              rvalue(P,
                cons_list(index_uni(r),
                  cons_list(index_uni(s), nil_index_list())), "P"), 0)) {
          current_statement__ = 357;
          assign(Pr,
            cons_list(index_uni(r),
              cons_list(index_uni(s), nil_index_list())), 0,
            "assigning variable Pr");
        } 
        current_statement__ = 360;
        if (logical_gt(
              rvalue(P,
                cons_list(index_uni(r),
                  cons_list(index_uni(s), nil_index_list())), "P"), 1)) {
          current_statement__ = 359;
          assign(Pr,
            cons_list(index_uni(r),
              cons_list(index_uni(s), nil_index_list())), 1,
            "assigning variable Pr");
        } }}
    current_statement__ = 365;
    return Pr;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct defuzz_P_functor__ {
template <typename T0__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>>, -1, -1>
operator()(const T0__& P, std::ostream* pstream__)  const 
{
return defuzz_P(P, pstream__);
}
};
template <typename T0__, typename T1__, typename T2__>
Eigen::Matrix<stan::promote_args_t<T0__, T1__,
T2__>, -1, -1>
trans_probs(const T0__& i, const T1__& f, const T2__& r,
            std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T1__, T2__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    Eigen::Matrix<local_scalar_t__, -1, -1> P;
    P = Eigen::Matrix<local_scalar_t__, -1, -1>(3, 3);
    stan::math::fill(P, DUMMY_VAR__);
    
    current_statement__ = 373;
    if (logical_neq(r, 0)) {
      current_statement__ = 372;
      assign(P, nil_index_list(), trans_probs_rem(i, f, r, pstream__),
        "assigning variable P");
    } else {
      current_statement__ = 370;
      if (logical_eq(i, f)) {
        current_statement__ = 369;
        assign(P, nil_index_list(), trans_probs_norem_i(i, pstream__),
          "assigning variable P");
      } else {
        current_statement__ = 368;
        assign(P, nil_index_list(), trans_probs_norem_if(i, f, pstream__),
          "assigning variable P");
      }
    }
    current_statement__ = 374;
    return defuzz_P(P, pstream__);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct trans_probs_functor__ {
template <typename T0__, typename T1__, typename T2__>
Eigen::Matrix<stan::promote_args_t<T0__, T1__,
T2__>, -1, -1>
operator()(const T0__& i, const T1__& f, const T2__& r,
           std::ostream* pstream__)  const 
{
return trans_probs(i, f, r, pstream__);
}
};
template <typename T0__>
stan::promote_args_t<T0__>
bound_prob(const T0__& x, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    local_scalar_t__ ret;
    ret = DUMMY_VAR__;
    
    current_statement__ = 384;
    if (logical_gte(x, 1)) {
      current_statement__ = 382;
      ret = (1 - stan::math::machine_precision());
    } else {
      current_statement__ = 381;
      if (logical_lte(x, 0)) {
        current_statement__ = 379;
        ret = stan::math::machine_precision();
      } else {
        current_statement__ = 377;
        ret = x;
      }
    }
    current_statement__ = 385;
    return x;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct bound_prob_functor__ {
template <typename T0__>
stan::promote_args_t<T0__>
operator()(const T0__& x, std::ostream* pstream__)  const 
{
return bound_prob(x, pstream__);
}
};
#include <stan_meta_header.hpp>
class model_disbayes final : public model_base_crtp<model_disbayes> {
private:
  int inc_supplied;
  int prev_supplied;
  int smooth_cf;
  int smooth_inc;
  int smooth_rem;
  int remission;
  int trend;
  int prev_zero;
  int nage;
  int eqage;
  std::vector<int> mort_num;
  std::vector<int> mort_denom;
  std::vector<int> prev_num;
  std::vector<int> prev_denom;
  std::vector<int> inc_num;
  std::vector<int> inc_denom;
  std::vector<int> rem_num;
  std::vector<int> rem_denom;
  int nyr;
  int K;
  Eigen::Matrix<double, -1, -1> X;
  std::vector<double> sprior;
  int increasing_cf;
  int const_cf;
  int const_rem;
  int nbias;
  int incdata_ind;
  int prevdata_ind;
  Eigen::Matrix<double, -1, -1> inc_trend;
  Eigen::Matrix<double, -1, -1> cf_trend;
  std::vector<double> inc_prior;
  std::vector<double> cf_prior;
  std::vector<double> rem_prior;
  int scf_isfixed;
  int sinc_isfixed;
  int srem_isfixed;
  double lambda_cf_fixed;
  double lambda_inc_fixed;
  double lambda_rem_fixed;
  int inc_par_1dim__;
  int cf_par_1dim__;
  int rem_par_1dim__;
  int beta_1dim__;
  int lambda_cf_1dim__;
  int lambda_inc_1dim__;
  int beta_inc_1dim__;
  int lambda_rem_1dim__;
  int beta_rem_1dim__;
  int bias_loghr_1dim__;
  int cfbase_1dim__;
  int dcf_1dim__;
  int rem_prob_1dim__;
  int state_probs_1dim__;
  int cf_yr_1dim__;
  int cf_yr_2dim__;
  int inc_yr_1dim__;
  int inc_yr_2dim__;
  int state_probs_yr_1dim__;
  int state_probs_yr_2dim__;
  int ll_inc_1dim__;
  int ll_prev_1dim__;
  int ll_rem_1dim__;
  int ll_overall_1dim__;
 
public:
  ~model_disbayes() { }
  
  inline std::string model_name() const final { return "model_disbayes"; }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = stanc3 v2.26.1-1-g67504470", "stancflags = "};
  }
  
  
  model_disbayes(stan::io::var_context& context__,
                 unsigned int random_seed__ = 0,
                 std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static const char* function__ = "model_disbayes_namespace::model_disbayes";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      current_statement__ = 219;
      context__.validate_dims("data initialization","inc_supplied","int",
          context__.to_vec());
      inc_supplied = std::numeric_limits<int>::min();
      
      current_statement__ = 219;
      inc_supplied = context__.vals_i("inc_supplied")[(1 - 1)];
      current_statement__ = 220;
      context__.validate_dims("data initialization","prev_supplied","int",
          context__.to_vec());
      prev_supplied = std::numeric_limits<int>::min();
      
      current_statement__ = 220;
      prev_supplied = context__.vals_i("prev_supplied")[(1 - 1)];
      current_statement__ = 221;
      context__.validate_dims("data initialization","smooth_cf","int",
          context__.to_vec());
      smooth_cf = std::numeric_limits<int>::min();
      
      current_statement__ = 221;
      smooth_cf = context__.vals_i("smooth_cf")[(1 - 1)];
      current_statement__ = 222;
      context__.validate_dims("data initialization","smooth_inc","int",
          context__.to_vec());
      smooth_inc = std::numeric_limits<int>::min();
      
      current_statement__ = 222;
      smooth_inc = context__.vals_i("smooth_inc")[(1 - 1)];
      current_statement__ = 223;
      context__.validate_dims("data initialization","smooth_rem","int",
          context__.to_vec());
      smooth_rem = std::numeric_limits<int>::min();
      
      current_statement__ = 223;
      smooth_rem = context__.vals_i("smooth_rem")[(1 - 1)];
      current_statement__ = 224;
      context__.validate_dims("data initialization","remission","int",
          context__.to_vec());
      remission = std::numeric_limits<int>::min();
      
      current_statement__ = 224;
      remission = context__.vals_i("remission")[(1 - 1)];
      current_statement__ = 225;
      context__.validate_dims("data initialization","trend","int",
          context__.to_vec());
      trend = std::numeric_limits<int>::min();
      
      current_statement__ = 225;
      trend = context__.vals_i("trend")[(1 - 1)];
      current_statement__ = 226;
      context__.validate_dims("data initialization","prev_zero","int",
          context__.to_vec());
      prev_zero = std::numeric_limits<int>::min();
      
      current_statement__ = 226;
      prev_zero = context__.vals_i("prev_zero")[(1 - 1)];
      current_statement__ = 227;
      context__.validate_dims("data initialization","nage","int",
          context__.to_vec());
      nage = std::numeric_limits<int>::min();
      
      current_statement__ = 227;
      nage = context__.vals_i("nage")[(1 - 1)];
      current_statement__ = 227;
      current_statement__ = 227;
      check_greater_or_equal(function__, "nage", nage, 0);
      current_statement__ = 228;
      context__.validate_dims("data initialization","eqage","int",
          context__.to_vec());
      eqage = std::numeric_limits<int>::min();
      
      current_statement__ = 228;
      eqage = context__.vals_i("eqage")[(1 - 1)];
      current_statement__ = 228;
      current_statement__ = 228;
      check_greater_or_equal(function__, "eqage", eqage, 0);
      current_statement__ = 229;
      validate_non_negative_index("mort_num", "nage", nage);
      current_statement__ = 230;
      context__.validate_dims("data initialization","mort_num","int",
          context__.to_vec(nage));
      mort_num = std::vector<int>(nage, std::numeric_limits<int>::min());
      
      current_statement__ = 230;
      assign(mort_num, nil_index_list(), context__.vals_i("mort_num"),
        "assigning variable mort_num");
      current_statement__ = 230;
      for (int sym1__ = 1; sym1__ <= nage; ++sym1__) {
        current_statement__ = 230;
        current_statement__ = 230;
        check_greater_or_equal(function__, "mort_num[sym1__]",
                               mort_num[(sym1__ - 1)], 0);}
      current_statement__ = 231;
      validate_non_negative_index("mort_denom", "nage", nage);
      current_statement__ = 232;
      context__.validate_dims("data initialization","mort_denom","int",
          context__.to_vec(nage));
      mort_denom = std::vector<int>(nage, std::numeric_limits<int>::min());
      
      current_statement__ = 232;
      assign(mort_denom, nil_index_list(), context__.vals_i("mort_denom"),
        "assigning variable mort_denom");
      current_statement__ = 232;
      for (int sym1__ = 1; sym1__ <= nage; ++sym1__) {
        current_statement__ = 232;
        current_statement__ = 232;
        check_greater_or_equal(function__, "mort_denom[sym1__]",
                               mort_denom[(sym1__ - 1)], 0);}
      current_statement__ = 233;
      validate_non_negative_index("prev_num", "nage", nage);
      current_statement__ = 234;
      context__.validate_dims("data initialization","prev_num","int",
          context__.to_vec(nage));
      prev_num = std::vector<int>(nage, std::numeric_limits<int>::min());
      
      current_statement__ = 234;
      assign(prev_num, nil_index_list(), context__.vals_i("prev_num"),
        "assigning variable prev_num");
      current_statement__ = 234;
      for (int sym1__ = 1; sym1__ <= nage; ++sym1__) {
        current_statement__ = 234;
        current_statement__ = 234;
        check_greater_or_equal(function__, "prev_num[sym1__]",
                               prev_num[(sym1__ - 1)], 0);}
      current_statement__ = 235;
      validate_non_negative_index("prev_denom", "nage", nage);
      current_statement__ = 236;
      context__.validate_dims("data initialization","prev_denom","int",
          context__.to_vec(nage));
      prev_denom = std::vector<int>(nage, std::numeric_limits<int>::min());
      
      current_statement__ = 236;
      assign(prev_denom, nil_index_list(), context__.vals_i("prev_denom"),
        "assigning variable prev_denom");
      current_statement__ = 236;
      for (int sym1__ = 1; sym1__ <= nage; ++sym1__) {
        current_statement__ = 236;
        current_statement__ = 236;
        check_greater_or_equal(function__, "prev_denom[sym1__]",
                               prev_denom[(sym1__ - 1)], 0);}
      current_statement__ = 237;
      validate_non_negative_index("inc_num", "nage", nage);
      current_statement__ = 238;
      context__.validate_dims("data initialization","inc_num","int",
          context__.to_vec(nage));
      inc_num = std::vector<int>(nage, std::numeric_limits<int>::min());
      
      current_statement__ = 238;
      assign(inc_num, nil_index_list(), context__.vals_i("inc_num"),
        "assigning variable inc_num");
      current_statement__ = 238;
      for (int sym1__ = 1; sym1__ <= nage; ++sym1__) {
        current_statement__ = 238;
        current_statement__ = 238;
        check_greater_or_equal(function__, "inc_num[sym1__]",
                               inc_num[(sym1__ - 1)], 0);}
      current_statement__ = 239;
      validate_non_negative_index("inc_denom", "nage", nage);
      current_statement__ = 240;
      context__.validate_dims("data initialization","inc_denom","int",
          context__.to_vec(nage));
      inc_denom = std::vector<int>(nage, std::numeric_limits<int>::min());
      
      current_statement__ = 240;
      assign(inc_denom, nil_index_list(), context__.vals_i("inc_denom"),
        "assigning variable inc_denom");
      current_statement__ = 240;
      for (int sym1__ = 1; sym1__ <= nage; ++sym1__) {
        current_statement__ = 240;
        current_statement__ = 240;
        check_greater_or_equal(function__, "inc_denom[sym1__]",
                               inc_denom[(sym1__ - 1)], 0);}
      current_statement__ = 241;
      validate_non_negative_index("rem_num", "nage", nage);
      current_statement__ = 242;
      context__.validate_dims("data initialization","rem_num","int",
          context__.to_vec(nage));
      rem_num = std::vector<int>(nage, std::numeric_limits<int>::min());
      
      current_statement__ = 242;
      assign(rem_num, nil_index_list(), context__.vals_i("rem_num"),
        "assigning variable rem_num");
      current_statement__ = 242;
      for (int sym1__ = 1; sym1__ <= nage; ++sym1__) {
        current_statement__ = 242;
        current_statement__ = 242;
        check_greater_or_equal(function__, "rem_num[sym1__]",
                               rem_num[(sym1__ - 1)], 0);}
      current_statement__ = 243;
      validate_non_negative_index("rem_denom", "nage", nage);
      current_statement__ = 244;
      context__.validate_dims("data initialization","rem_denom","int",
          context__.to_vec(nage));
      rem_denom = std::vector<int>(nage, std::numeric_limits<int>::min());
      
      current_statement__ = 244;
      assign(rem_denom, nil_index_list(), context__.vals_i("rem_denom"),
        "assigning variable rem_denom");
      current_statement__ = 244;
      for (int sym1__ = 1; sym1__ <= nage; ++sym1__) {
        current_statement__ = 244;
        current_statement__ = 244;
        check_greater_or_equal(function__, "rem_denom[sym1__]",
                               rem_denom[(sym1__ - 1)], 0);}
      current_statement__ = 245;
      context__.validate_dims("data initialization","nyr","int",
          context__.to_vec());
      nyr = std::numeric_limits<int>::min();
      
      current_statement__ = 245;
      nyr = context__.vals_i("nyr")[(1 - 1)];
      current_statement__ = 245;
      current_statement__ = 245;
      check_greater_or_equal(function__, "nyr", nyr, 0);
      current_statement__ = 246;
      context__.validate_dims("data initialization","K","int",
          context__.to_vec());
      K = std::numeric_limits<int>::min();
      
      current_statement__ = 246;
      K = context__.vals_i("K")[(1 - 1)];
      current_statement__ = 246;
      current_statement__ = 246;
      check_greater_or_equal(function__, "K", K, 0);
      current_statement__ = 247;
      validate_non_negative_index("X", "nage", nage);
      current_statement__ = 248;
      validate_non_negative_index("X", "K", K);
      current_statement__ = 249;
      context__.validate_dims("data initialization","X","double",
          context__.to_vec(nage, K));
      X = Eigen::Matrix<double, -1, -1>(nage, K);
      stan::math::fill(X, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> X_flat__;
        current_statement__ = 249;
        assign(X_flat__, nil_index_list(), context__.vals_r("X"),
          "assigning variable X_flat__");
        current_statement__ = 249;
        pos__ = 1;
        current_statement__ = 249;
        for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
          current_statement__ = 249;
          for (int sym2__ = 1; sym2__ <= nage; ++sym2__) {
            current_statement__ = 249;
            assign(X,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              X_flat__[(pos__ - 1)], "assigning variable X");
            current_statement__ = 249;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 250;
      context__.validate_dims("data initialization","sprior","double",
          context__.to_vec(3));
      sprior = std::vector<double>(3, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 250;
      assign(sprior, nil_index_list(), context__.vals_r("sprior"),
        "assigning variable sprior");
      current_statement__ = 250;
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        current_statement__ = 250;
        current_statement__ = 250;
        check_greater_or_equal(function__, "sprior[sym1__]",
                               sprior[(sym1__ - 1)], 0);}
      current_statement__ = 251;
      context__.validate_dims("data initialization","increasing_cf","int",
          context__.to_vec());
      increasing_cf = std::numeric_limits<int>::min();
      
      current_statement__ = 251;
      increasing_cf = context__.vals_i("increasing_cf")[(1 - 1)];
      current_statement__ = 252;
      context__.validate_dims("data initialization","const_cf","int",
          context__.to_vec());
      const_cf = std::numeric_limits<int>::min();
      
      current_statement__ = 252;
      const_cf = context__.vals_i("const_cf")[(1 - 1)];
      current_statement__ = 253;
      context__.validate_dims("data initialization","const_rem","int",
          context__.to_vec());
      const_rem = std::numeric_limits<int>::min();
      
      current_statement__ = 253;
      const_rem = context__.vals_i("const_rem")[(1 - 1)];
      current_statement__ = 254;
      context__.validate_dims("data initialization","nbias","int",
          context__.to_vec());
      nbias = std::numeric_limits<int>::min();
      
      current_statement__ = 254;
      nbias = context__.vals_i("nbias")[(1 - 1)];
      current_statement__ = 255;
      context__.validate_dims("data initialization","incdata_ind","int",
          context__.to_vec());
      incdata_ind = std::numeric_limits<int>::min();
      
      current_statement__ = 255;
      incdata_ind = context__.vals_i("incdata_ind")[(1 - 1)];
      current_statement__ = 256;
      context__.validate_dims("data initialization","prevdata_ind","int",
          context__.to_vec());
      prevdata_ind = std::numeric_limits<int>::min();
      
      current_statement__ = 256;
      prevdata_ind = context__.vals_i("prevdata_ind")[(1 - 1)];
      current_statement__ = 257;
      validate_non_negative_index("inc_trend", "nage", nage);
      current_statement__ = 258;
      validate_non_negative_index("inc_trend", "nyr", nyr);
      current_statement__ = 259;
      context__.validate_dims("data initialization","inc_trend","double",
          context__.to_vec(nage, nyr));
      inc_trend = Eigen::Matrix<double, -1, -1>(nage, nyr);
      stan::math::fill(inc_trend, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> inc_trend_flat__;
        current_statement__ = 259;
        assign(inc_trend_flat__, nil_index_list(),
          context__.vals_r("inc_trend"),
          "assigning variable inc_trend_flat__");
        current_statement__ = 259;
        pos__ = 1;
        current_statement__ = 259;
        for (int sym1__ = 1; sym1__ <= nyr; ++sym1__) {
          current_statement__ = 259;
          for (int sym2__ = 1; sym2__ <= nage; ++sym2__) {
            current_statement__ = 259;
            assign(inc_trend,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              inc_trend_flat__[(pos__ - 1)], "assigning variable inc_trend");
            current_statement__ = 259;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 259;
      for (int sym1__ = 1; sym1__ <= nage; ++sym1__) {
        current_statement__ = 259;
        for (int sym2__ = 1; sym2__ <= nyr; ++sym2__) {
          current_statement__ = 259;
          current_statement__ = 259;
          check_greater_or_equal(function__, "inc_trend[sym1__, sym2__]",
                                 rvalue(inc_trend,
                                   cons_list(index_uni(sym1__),
                                     cons_list(index_uni(sym2__),
                                       nil_index_list())), "inc_trend"), 0);}
      }
      current_statement__ = 260;
      validate_non_negative_index("cf_trend", "nage", nage);
      current_statement__ = 261;
      validate_non_negative_index("cf_trend", "nyr", nyr);
      current_statement__ = 262;
      context__.validate_dims("data initialization","cf_trend","double",
          context__.to_vec(nage, nyr));
      cf_trend = Eigen::Matrix<double, -1, -1>(nage, nyr);
      stan::math::fill(cf_trend, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> cf_trend_flat__;
        current_statement__ = 262;
        assign(cf_trend_flat__, nil_index_list(),
          context__.vals_r("cf_trend"), "assigning variable cf_trend_flat__");
        current_statement__ = 262;
        pos__ = 1;
        current_statement__ = 262;
        for (int sym1__ = 1; sym1__ <= nyr; ++sym1__) {
          current_statement__ = 262;
          for (int sym2__ = 1; sym2__ <= nage; ++sym2__) {
            current_statement__ = 262;
            assign(cf_trend,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              cf_trend_flat__[(pos__ - 1)], "assigning variable cf_trend");
            current_statement__ = 262;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 262;
      for (int sym1__ = 1; sym1__ <= nage; ++sym1__) {
        current_statement__ = 262;
        for (int sym2__ = 1; sym2__ <= nyr; ++sym2__) {
          current_statement__ = 262;
          current_statement__ = 262;
          check_greater_or_equal(function__, "cf_trend[sym1__, sym2__]",
                                 rvalue(cf_trend,
                                   cons_list(index_uni(sym1__),
                                     cons_list(index_uni(sym2__),
                                       nil_index_list())), "cf_trend"), 0);}}
      current_statement__ = 263;
      context__.validate_dims("data initialization","inc_prior","double",
          context__.to_vec(2));
      inc_prior = std::vector<double>(2, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 263;
      assign(inc_prior, nil_index_list(), context__.vals_r("inc_prior"),
        "assigning variable inc_prior");
      current_statement__ = 263;
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        current_statement__ = 263;
        current_statement__ = 263;
        check_greater_or_equal(function__, "inc_prior[sym1__]",
                               inc_prior[(sym1__ - 1)], 0);}
      current_statement__ = 264;
      context__.validate_dims("data initialization","cf_prior","double",
          context__.to_vec(2));
      cf_prior = std::vector<double>(2, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 264;
      assign(cf_prior, nil_index_list(), context__.vals_r("cf_prior"),
        "assigning variable cf_prior");
      current_statement__ = 264;
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        current_statement__ = 264;
        current_statement__ = 264;
        check_greater_or_equal(function__, "cf_prior[sym1__]",
                               cf_prior[(sym1__ - 1)], 0);}
      current_statement__ = 265;
      context__.validate_dims("data initialization","rem_prior","double",
          context__.to_vec(2));
      rem_prior = std::vector<double>(2, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 265;
      assign(rem_prior, nil_index_list(), context__.vals_r("rem_prior"),
        "assigning variable rem_prior");
      current_statement__ = 265;
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        current_statement__ = 265;
        current_statement__ = 265;
        check_greater_or_equal(function__, "rem_prior[sym1__]",
                               rem_prior[(sym1__ - 1)], 0);}
      current_statement__ = 266;
      context__.validate_dims("data initialization","scf_isfixed","int",
          context__.to_vec());
      scf_isfixed = std::numeric_limits<int>::min();
      
      current_statement__ = 266;
      scf_isfixed = context__.vals_i("scf_isfixed")[(1 - 1)];
      current_statement__ = 267;
      context__.validate_dims("data initialization","sinc_isfixed","int",
          context__.to_vec());
      sinc_isfixed = std::numeric_limits<int>::min();
      
      current_statement__ = 267;
      sinc_isfixed = context__.vals_i("sinc_isfixed")[(1 - 1)];
      current_statement__ = 268;
      context__.validate_dims("data initialization","srem_isfixed","int",
          context__.to_vec());
      srem_isfixed = std::numeric_limits<int>::min();
      
      current_statement__ = 268;
      srem_isfixed = context__.vals_i("srem_isfixed")[(1 - 1)];
      current_statement__ = 269;
      context__.validate_dims("data initialization","lambda_cf_fixed",
          "double",context__.to_vec());
      lambda_cf_fixed = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 269;
      lambda_cf_fixed = context__.vals_r("lambda_cf_fixed")[(1 - 1)];
      current_statement__ = 269;
      current_statement__ = 269;
      check_greater_or_equal(function__, "lambda_cf_fixed", lambda_cf_fixed,
                             0);
      current_statement__ = 270;
      context__.validate_dims("data initialization","lambda_inc_fixed",
          "double",context__.to_vec());
      lambda_inc_fixed = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 270;
      lambda_inc_fixed = context__.vals_r("lambda_inc_fixed")[(1 - 1)];
      current_statement__ = 270;
      current_statement__ = 270;
      check_greater_or_equal(function__, "lambda_inc_fixed",
                             lambda_inc_fixed, 0);
      current_statement__ = 271;
      context__.validate_dims("data initialization","lambda_rem_fixed",
          "double",context__.to_vec());
      lambda_rem_fixed = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 271;
      lambda_rem_fixed = context__.vals_r("lambda_rem_fixed")[(1 - 1)];
      current_statement__ = 271;
      current_statement__ = 271;
      check_greater_or_equal(function__, "lambda_rem_fixed",
                             lambda_rem_fixed, 0);
      current_statement__ = 272;
      inc_par_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 272;
      inc_par_1dim__ = (nage * (1 - smooth_inc));
      current_statement__ = 272;
      validate_non_negative_index("inc_par", "nage * (1 - smooth_inc)",
                                  inc_par_1dim__);
      current_statement__ = 273;
      cf_par_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 273;
      cf_par_1dim__ = (nage * (1 - smooth_cf));
      current_statement__ = 273;
      validate_non_negative_index("cf_par", "nage * (1 - smooth_cf)",
                                  cf_par_1dim__);
      current_statement__ = 274;
      rem_par_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 274;
      rem_par_1dim__ = ((remission * (1 - smooth_rem)) *
                         ((nage * (1 - const_rem)) + (1 * const_rem)));
      current_statement__ = 274;
      validate_non_negative_index("rem_par",
                                  "remission * (1 - smooth_rem) * (nage * (1 - const_rem) + 1 * const_rem)",
                                  rem_par_1dim__);
      current_statement__ = 275;
      beta_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 275;
      beta_1dim__ = ((K * smooth_cf) * (1 - const_cf));
      current_statement__ = 275;
      validate_non_negative_index("beta", "K * smooth_cf * (1 - const_cf)",
                                  beta_1dim__);
      current_statement__ = 276;
      lambda_cf_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 276;
      lambda_cf_1dim__ = (smooth_cf * (1 - scf_isfixed));
      current_statement__ = 276;
      validate_non_negative_index("lambda_cf",
                                  "smooth_cf * (1 - scf_isfixed)",
                                  lambda_cf_1dim__);
      current_statement__ = 277;
      lambda_inc_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 277;
      lambda_inc_1dim__ = (smooth_inc * (1 - sinc_isfixed));
      current_statement__ = 277;
      validate_non_negative_index("lambda_inc",
                                  "smooth_inc * (1 - sinc_isfixed)",
                                  lambda_inc_1dim__);
      current_statement__ = 278;
      beta_inc_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 278;
      beta_inc_1dim__ = (K * smooth_inc);
      current_statement__ = 278;
      validate_non_negative_index("beta_inc", "K * smooth_inc",
                                  beta_inc_1dim__);
      current_statement__ = 279;
      lambda_rem_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 279;
      lambda_rem_1dim__ = (smooth_rem * (1 - srem_isfixed));
      current_statement__ = 279;
      validate_non_negative_index("lambda_rem",
                                  "smooth_rem * (1 - srem_isfixed)",
                                  lambda_rem_1dim__);
      current_statement__ = 280;
      beta_rem_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 280;
      beta_rem_1dim__ = (K * smooth_rem);
      current_statement__ = 280;
      validate_non_negative_index("beta_rem", "K * smooth_rem",
                                  beta_rem_1dim__);
      current_statement__ = 281;
      validate_non_negative_index("prevzero", "prev_zero", prev_zero);
      current_statement__ = 282;
      bias_loghr_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 282;
      bias_loghr_1dim__ = logical_eq(nbias, 2);
      current_statement__ = 282;
      validate_non_negative_index("bias_loghr", "nbias == 2",
                                  bias_loghr_1dim__);
      current_statement__ = 283;
      cfbase_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 283;
      cfbase_1dim__ = (1 * increasing_cf);
      current_statement__ = 283;
      validate_non_negative_index("cfbase", "1 * increasing_cf",
                                  cfbase_1dim__);
      current_statement__ = 284;
      validate_non_negative_index("cf", "nage", nage);
      current_statement__ = 285;
      dcf_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 285;
      dcf_1dim__ = (nage * increasing_cf);
      current_statement__ = 285;
      validate_non_negative_index("dcf", "nage * increasing_cf", dcf_1dim__);
      current_statement__ = 286;
      validate_non_negative_index("inc", "nage", nage);
      current_statement__ = 287;
      validate_non_negative_index("inc", "nbias", nbias);
      current_statement__ = 288;
      validate_non_negative_index("inc_prob", "nage", nage);
      current_statement__ = 289;
      validate_non_negative_index("inc_prob", "nbias", nbias);
      current_statement__ = 290;
      validate_non_negative_index("rem", "nage", nage);
      current_statement__ = 291;
      rem_prob_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 291;
      rem_prob_1dim__ = (nage * remission);
      current_statement__ = 291;
      validate_non_negative_index("rem_prob", "nage * remission",
                                  rem_prob_1dim__);
      current_statement__ = 292;
      validate_non_negative_index("cf_prob", "nage", nage);
      current_statement__ = 293;
      state_probs_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 293;
      state_probs_1dim__ = ((nage + 1) * (1 - trend));
      current_statement__ = 293;
      validate_non_negative_index("state_probs", "(nage + 1) * (1 - trend)",
                                  state_probs_1dim__);
      current_statement__ = 294;
      validate_non_negative_index("state_probs", "nbias", nbias);
      current_statement__ = 295;
      validate_non_negative_index("prev_prob", "nage", nage);
      current_statement__ = 296;
      validate_non_negative_index("prev_prob", "nbias", nbias);
      current_statement__ = 297;
      validate_non_negative_index("mort_prob", "nage", nage);
      current_statement__ = 298;
      cf_yr_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 298;
      cf_yr_1dim__ = (nage * trend);
      current_statement__ = 298;
      validate_non_negative_index("cf_yr", "nage * trend", cf_yr_1dim__);
      current_statement__ = 299;
      cf_yr_2dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 299;
      cf_yr_2dim__ = (nyr * trend);
      current_statement__ = 299;
      validate_non_negative_index("cf_yr", "nyr * trend", cf_yr_2dim__);
      current_statement__ = 300;
      inc_yr_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 300;
      inc_yr_1dim__ = (nage * trend);
      current_statement__ = 300;
      validate_non_negative_index("inc_yr", "nage * trend", inc_yr_1dim__);
      current_statement__ = 301;
      inc_yr_2dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 301;
      inc_yr_2dim__ = (nyr * trend);
      current_statement__ = 301;
      validate_non_negative_index("inc_yr", "nyr * trend", inc_yr_2dim__);
      current_statement__ = 302;
      validate_non_negative_index("inc_yr", "nbias", nbias);
      current_statement__ = 303;
      state_probs_yr_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 303;
      state_probs_yr_1dim__ = ((nage + 1) * trend);
      current_statement__ = 303;
      validate_non_negative_index("state_probs_yr", "(nage + 1) * trend",
                                  state_probs_yr_1dim__);
      current_statement__ = 304;
      state_probs_yr_2dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 304;
      state_probs_yr_2dim__ = (nyr * trend);
      current_statement__ = 304;
      validate_non_negative_index("state_probs_yr", "nyr * trend",
                                  state_probs_yr_2dim__);
      current_statement__ = 305;
      validate_non_negative_index("state_probs_yr", "nbias", nbias);
      current_statement__ = 306;
      validate_non_negative_index("ll_mort", "nage", nage);
      current_statement__ = 307;
      ll_inc_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 307;
      ll_inc_1dim__ = (nage * inc_supplied);
      current_statement__ = 307;
      validate_non_negative_index("ll_inc", "nage * inc_supplied",
                                  ll_inc_1dim__);
      current_statement__ = 308;
      ll_prev_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 308;
      ll_prev_1dim__ = (nage * prev_supplied);
      current_statement__ = 308;
      validate_non_negative_index("ll_prev", "nage * prev_supplied",
                                  ll_prev_1dim__);
      current_statement__ = 309;
      ll_rem_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 309;
      ll_rem_1dim__ = (nage * remission);
      current_statement__ = 309;
      validate_non_negative_index("ll_rem", "nage * remission", ll_rem_1dim__);
      current_statement__ = 310;
      ll_overall_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 310;
      ll_overall_1dim__ = (nage *
                            (((1 + inc_supplied) + prev_supplied) +
                              remission));
      current_statement__ = 310;
      validate_non_negative_index("ll_overall",
                                  "nage * (1 + inc_supplied + prev_supplied + remission)",
                                  ll_overall_1dim__);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 0U;
    
    try {
      num_params_r__ += inc_par_1dim__;
      num_params_r__ += cf_par_1dim__;
      num_params_r__ += rem_par_1dim__;
      num_params_r__ += beta_1dim__;
      num_params_r__ += lambda_cf_1dim__;
      num_params_r__ += lambda_inc_1dim__;
      num_params_r__ += beta_inc_1dim__;
      num_params_r__ += lambda_rem_1dim__;
      num_params_r__ += beta_rem_1dim__;
      num_params_r__ += prev_zero;
      num_params_r__ += bias_loghr_1dim__;
      num_params_r__ += cfbase_1dim__;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
  }
  template <bool propto__, bool jacobian__, typename VecR, typename VecI, stan::require_vector_like_t<VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    static const char* function__ = "model_disbayes_namespace::log_prob";
(void) function__;  // suppress unused var warning
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    
    try {
      Eigen::Matrix<local_scalar_t__, -1, 1> inc_par;
      inc_par = Eigen::Matrix<local_scalar_t__, -1, 1>(inc_par_1dim__);
      stan::math::fill(inc_par, DUMMY_VAR__);
      
      current_statement__ = 1;
      inc_par = in__.vector(inc_par_1dim__);
      current_statement__ = 1;
      for (int sym1__ = 1; sym1__ <= inc_par_1dim__; ++sym1__) {
        current_statement__ = 1;
        if (jacobian__) {
          current_statement__ = 1;
          assign(inc_par, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(inc_par[(sym1__ - 1)], 0, lp__),
            "assigning variable inc_par");
        } else {
          current_statement__ = 1;
          assign(inc_par, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(inc_par[(sym1__ - 1)], 0),
            "assigning variable inc_par");
        }}
      Eigen::Matrix<local_scalar_t__, -1, 1> cf_par;
      cf_par = Eigen::Matrix<local_scalar_t__, -1, 1>(cf_par_1dim__);
      stan::math::fill(cf_par, DUMMY_VAR__);
      
      current_statement__ = 2;
      cf_par = in__.vector(cf_par_1dim__);
      current_statement__ = 2;
      for (int sym1__ = 1; sym1__ <= cf_par_1dim__; ++sym1__) {
        current_statement__ = 2;
        if (jacobian__) {
          current_statement__ = 2;
          assign(cf_par, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(cf_par[(sym1__ - 1)], 0, lp__),
            "assigning variable cf_par");
        } else {
          current_statement__ = 2;
          assign(cf_par, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(cf_par[(sym1__ - 1)], 0),
            "assigning variable cf_par");
        }}
      Eigen::Matrix<local_scalar_t__, -1, 1> rem_par;
      rem_par = Eigen::Matrix<local_scalar_t__, -1, 1>(rem_par_1dim__);
      stan::math::fill(rem_par, DUMMY_VAR__);
      
      current_statement__ = 3;
      rem_par = in__.vector(rem_par_1dim__);
      current_statement__ = 3;
      for (int sym1__ = 1; sym1__ <= rem_par_1dim__; ++sym1__) {
        current_statement__ = 3;
        if (jacobian__) {
          current_statement__ = 3;
          assign(rem_par, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(rem_par[(sym1__ - 1)], 0, lp__),
            "assigning variable rem_par");
        } else {
          current_statement__ = 3;
          assign(rem_par, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(rem_par[(sym1__ - 1)], 0),
            "assigning variable rem_par");
        }}
      Eigen::Matrix<local_scalar_t__, -1, 1> beta;
      beta = Eigen::Matrix<local_scalar_t__, -1, 1>(beta_1dim__);
      stan::math::fill(beta, DUMMY_VAR__);
      
      current_statement__ = 4;
      beta = in__.vector(beta_1dim__);
      Eigen::Matrix<local_scalar_t__, -1, 1> lambda_cf;
      lambda_cf = Eigen::Matrix<local_scalar_t__, -1, 1>(lambda_cf_1dim__);
      stan::math::fill(lambda_cf, DUMMY_VAR__);
      
      current_statement__ = 5;
      lambda_cf = in__.vector(lambda_cf_1dim__);
      current_statement__ = 5;
      for (int sym1__ = 1; sym1__ <= lambda_cf_1dim__; ++sym1__) {
        current_statement__ = 5;
        if (jacobian__) {
          current_statement__ = 5;
          assign(lambda_cf, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(lambda_cf[(sym1__ - 1)], 0, lp__),
            "assigning variable lambda_cf");
        } else {
          current_statement__ = 5;
          assign(lambda_cf, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(lambda_cf[(sym1__ - 1)], 0),
            "assigning variable lambda_cf");
        }}
      Eigen::Matrix<local_scalar_t__, -1, 1> lambda_inc;
      lambda_inc = Eigen::Matrix<local_scalar_t__, -1, 1>(lambda_inc_1dim__);
      stan::math::fill(lambda_inc, DUMMY_VAR__);
      
      current_statement__ = 6;
      lambda_inc = in__.vector(lambda_inc_1dim__);
      current_statement__ = 6;
      for (int sym1__ = 1; sym1__ <= lambda_inc_1dim__; ++sym1__) {
        current_statement__ = 6;
        if (jacobian__) {
          current_statement__ = 6;
          assign(lambda_inc, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(lambda_inc[(sym1__ - 1)], 0, lp__),
            "assigning variable lambda_inc");
        } else {
          current_statement__ = 6;
          assign(lambda_inc, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(lambda_inc[(sym1__ - 1)], 0),
            "assigning variable lambda_inc");
        }}
      Eigen::Matrix<local_scalar_t__, -1, 1> beta_inc;
      beta_inc = Eigen::Matrix<local_scalar_t__, -1, 1>(beta_inc_1dim__);
      stan::math::fill(beta_inc, DUMMY_VAR__);
      
      current_statement__ = 7;
      beta_inc = in__.vector(beta_inc_1dim__);
      Eigen::Matrix<local_scalar_t__, -1, 1> lambda_rem;
      lambda_rem = Eigen::Matrix<local_scalar_t__, -1, 1>(lambda_rem_1dim__);
      stan::math::fill(lambda_rem, DUMMY_VAR__);
      
      current_statement__ = 8;
      lambda_rem = in__.vector(lambda_rem_1dim__);
      current_statement__ = 8;
      for (int sym1__ = 1; sym1__ <= lambda_rem_1dim__; ++sym1__) {
        current_statement__ = 8;
        if (jacobian__) {
          current_statement__ = 8;
          assign(lambda_rem, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(lambda_rem[(sym1__ - 1)], 0, lp__),
            "assigning variable lambda_rem");
        } else {
          current_statement__ = 8;
          assign(lambda_rem, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(lambda_rem[(sym1__ - 1)], 0),
            "assigning variable lambda_rem");
        }}
      Eigen::Matrix<local_scalar_t__, -1, 1> beta_rem;
      beta_rem = Eigen::Matrix<local_scalar_t__, -1, 1>(beta_rem_1dim__);
      stan::math::fill(beta_rem, DUMMY_VAR__);
      
      current_statement__ = 9;
      beta_rem = in__.vector(beta_rem_1dim__);
      Eigen::Matrix<local_scalar_t__, -1, 1> prevzero;
      prevzero = Eigen::Matrix<local_scalar_t__, -1, 1>(prev_zero);
      stan::math::fill(prevzero, DUMMY_VAR__);
      
      current_statement__ = 10;
      prevzero = in__.vector(prev_zero);
      current_statement__ = 10;
      for (int sym1__ = 1; sym1__ <= prev_zero; ++sym1__) {
        current_statement__ = 10;
        if (jacobian__) {
          current_statement__ = 10;
          assign(prevzero, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lub_constrain(prevzero[(sym1__ - 1)], 0, 1, lp__),
            "assigning variable prevzero");
        } else {
          current_statement__ = 10;
          assign(prevzero, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lub_constrain(prevzero[(sym1__ - 1)], 0, 1),
            "assigning variable prevzero");
        }}
      Eigen::Matrix<local_scalar_t__, -1, 1> bias_loghr;
      bias_loghr = Eigen::Matrix<local_scalar_t__, -1, 1>(bias_loghr_1dim__);
      stan::math::fill(bias_loghr, DUMMY_VAR__);
      
      current_statement__ = 11;
      bias_loghr = in__.vector(bias_loghr_1dim__);
      Eigen::Matrix<local_scalar_t__, -1, 1> cfbase;
      cfbase = Eigen::Matrix<local_scalar_t__, -1, 1>(cfbase_1dim__);
      stan::math::fill(cfbase, DUMMY_VAR__);
      
      current_statement__ = 12;
      cfbase = in__.vector(cfbase_1dim__);
      current_statement__ = 12;
      for (int sym1__ = 1; sym1__ <= cfbase_1dim__; ++sym1__) {
        current_statement__ = 12;
        if (jacobian__) {
          current_statement__ = 12;
          assign(cfbase, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(cfbase[(sym1__ - 1)], 0, lp__),
            "assigning variable cfbase");
        } else {
          current_statement__ = 12;
          assign(cfbase, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(cfbase[(sym1__ - 1)], 0),
            "assigning variable cfbase");
        }}
      Eigen::Matrix<local_scalar_t__, -1, 1> cf;
      cf = Eigen::Matrix<local_scalar_t__, -1, 1>(nage);
      stan::math::fill(cf, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, 1> dcf;
      dcf = Eigen::Matrix<local_scalar_t__, -1, 1>(dcf_1dim__);
      stan::math::fill(dcf, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, -1> inc;
      inc = Eigen::Matrix<local_scalar_t__, -1, -1>(nage, nbias);
      stan::math::fill(inc, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, -1> inc_prob;
      inc_prob = Eigen::Matrix<local_scalar_t__, -1, -1>(nage, nbias);
      stan::math::fill(inc_prob, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, 1> rem;
      rem = Eigen::Matrix<local_scalar_t__, -1, 1>(nage);
      stan::math::fill(rem, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, 1> rem_prob;
      rem_prob = Eigen::Matrix<local_scalar_t__, -1, 1>(rem_prob_1dim__);
      stan::math::fill(rem_prob, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, 1> cf_prob;
      cf_prob = Eigen::Matrix<local_scalar_t__, -1, 1>(nage);
      stan::math::fill(cf_prob, DUMMY_VAR__);
      
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__, 1, -1>>> state_probs;
      state_probs = std::vector<std::vector<Eigen::Matrix<local_scalar_t__, 1, -1>>>(state_probs_1dim__, std::vector<Eigen::Matrix<local_scalar_t__, 1, -1>>(nbias, Eigen::Matrix<local_scalar_t__, 1, -1>(3)));
      stan::math::fill(state_probs, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, 1, -1> tmp;
      tmp = Eigen::Matrix<local_scalar_t__, 1, -1>(3);
      stan::math::fill(tmp, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, -1> P;
      P = Eigen::Matrix<local_scalar_t__, -1, -1>(3, 3);
      stan::math::fill(P, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, -1> prev_prob;
      prev_prob = Eigen::Matrix<local_scalar_t__, -1, -1>(nage, nbias);
      stan::math::fill(prev_prob, DUMMY_VAR__);
      
      std::vector<local_scalar_t__> mort_prob;
      mort_prob = std::vector<local_scalar_t__>(nage, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, -1> cf_yr;
      cf_yr = Eigen::Matrix<local_scalar_t__, -1, -1>(cf_yr_1dim__, cf_yr_2dim__);
      stan::math::fill(cf_yr, DUMMY_VAR__);
      
      std::vector<std::vector<std::vector<local_scalar_t__>>> inc_yr;
      inc_yr = std::vector<std::vector<std::vector<local_scalar_t__>>>(inc_yr_1dim__, std::vector<std::vector<local_scalar_t__>>(inc_yr_2dim__, std::vector<local_scalar_t__>(nbias, DUMMY_VAR__)));
      
      std::vector<std::vector<std::vector<Eigen::Matrix<local_scalar_t__, 1, -1>>>> state_probs_yr;
      state_probs_yr = std::vector<std::vector<std::vector<Eigen::Matrix<local_scalar_t__, 1, -1>>>>(state_probs_yr_1dim__, std::vector<std::vector<Eigen::Matrix<local_scalar_t__, 1, -1>>>(state_probs_yr_2dim__, std::vector<Eigen::Matrix<local_scalar_t__, 1, -1>>(nbias, Eigen::Matrix<local_scalar_t__, 1, -1>(3))));
      stan::math::fill(state_probs_yr, DUMMY_VAR__);
      
      local_scalar_t__ lambda_cf_use;
      lambda_cf_use = DUMMY_VAR__;
      
      local_scalar_t__ lambda_inc_use;
      lambda_inc_use = DUMMY_VAR__;
      
      local_scalar_t__ lambda_rem_use;
      lambda_rem_use = DUMMY_VAR__;
      
      current_statement__ = 33;
      if ((primitive_value(scf_isfixed) || primitive_value(
          logical_negation(smooth_cf)))) {
        current_statement__ = 32;
        lambda_cf_use = lambda_cf_fixed;
      } else {
        current_statement__ = 31;
        lambda_cf_use = lambda_cf[(1 - 1)];
      }
      current_statement__ = 36;
      if ((primitive_value(sinc_isfixed) || primitive_value(
          logical_negation(smooth_inc)))) {
        current_statement__ = 35;
        lambda_inc_use = lambda_inc_fixed;
      } else {
        current_statement__ = 34;
        lambda_inc_use = lambda_inc[(1 - 1)];
      }
      current_statement__ = 39;
      if ((primitive_value(srem_isfixed) || primitive_value(
          logical_negation(smooth_rem)))) {
        current_statement__ = 38;
        lambda_rem_use = lambda_rem_fixed;
      } else {
        current_statement__ = 37;
        lambda_rem_use = lambda_rem[(1 - 1)];
      }
      current_statement__ = 42;
      if (smooth_inc) {
        current_statement__ = 41;
        assign(inc,
          cons_list(index_min_max(1, nage),
            cons_list(index_uni(1), nil_index_list())),
          stan::math::exp(multiply(X, beta_inc)), "assigning variable inc");
      } else {
        current_statement__ = 40;
        assign(inc,
          cons_list(index_min_max(1, nage),
            cons_list(index_uni(1), nil_index_list())), inc_par,
          "assigning variable inc");
      }
      current_statement__ = 45;
      if (logical_gt(nbias, 1)) {
        current_statement__ = 43;
        assign(inc,
          cons_list(index_min_max(1, nage),
            cons_list(index_uni(2), nil_index_list())),
          stan::math::exp(
            add(
              stan::math::log(
                stan::model::deep_copy(
                  rvalue(inc,
                    cons_list(index_min_max(1, nage),
                      cons_list(index_uni(1), nil_index_list())), "inc"))),
              bias_loghr[(1 - 1)])), "assigning variable inc");
      } 
      current_statement__ = 55;
      if (remission) {
        current_statement__ = 53;
        if (const_rem) {
          current_statement__ = 51;
          for (int a = 1; a <= nage; ++a) {
            current_statement__ = 50;
            assign(rem, cons_list(index_uni(a), nil_index_list()),
              rem_par[(1 - 1)], "assigning variable rem");}
        } else {
          current_statement__ = 49;
          if (smooth_rem) {
            current_statement__ = 48;
            assign(rem, nil_index_list(),
              stan::math::exp(multiply(X, beta_rem)),
              "assigning variable rem");
          } else {
            current_statement__ = 47;
            assign(rem, nil_index_list(), rem_par, "assigning variable rem");
          }
        }
      } else {
        current_statement__ = 46;
        assign(rem, nil_index_list(), rep_vector(0, nage),
          "assigning variable rem");
      }
      current_statement__ = 60;
      for (int k = 1; k <= nbias; ++k) {
        current_statement__ = 58;
        if ((primitive_value(logical_gt(prev_denom[(1 - 1)], 0)) &&
            primitive_value((primitive_value(
            logical_gt(prev_num[(1 - 1)], 0)) || primitive_value(
            prev_zero))))) {
          current_statement__ = 57;
          assign(prev_prob,
            cons_list(index_uni(1),
              cons_list(index_uni(k), nil_index_list())), prevzero[(1 - 1)],
            "assigning variable prev_prob");
        } else {
          current_statement__ = 56;
          assign(prev_prob,
            cons_list(index_uni(1),
              cons_list(index_uni(k), nil_index_list())), 0,
            "assigning variable prev_prob");
        }}
      current_statement__ = 76;
      if (increasing_cf) {
        current_statement__ = 67;
        for (int a = 1; a <= (eqage - 1); ++a) {
          current_statement__ = 65;
          assign(cf, cons_list(index_uni(a), nil_index_list()),
            cfbase[(1 - 1)], "assigning variable cf");}
        current_statement__ = 71;
        if (logical_negation(const_cf)) {
          current_statement__ = 69;
          assign(dcf, nil_index_list(), stan::math::exp(multiply(X, beta)),
            "assigning variable dcf");
        } else {
          current_statement__ = 68;
          assign(dcf, nil_index_list(), rep_vector(0, nage),
            "assigning variable dcf");
        }
        current_statement__ = 74;
        for (int a = eqage; a <= nage; ++a) {
          current_statement__ = 72;
          assign(cf, cons_list(index_uni(a), nil_index_list()),
            (cf[((a - 1) - 1)] + dcf[(a - 1)]), "assigning variable cf");}
      } else {
        current_statement__ = 63;
        if (smooth_cf) {
          current_statement__ = 62;
          assign(cf, nil_index_list(), stan::math::exp(multiply(X, beta)),
            "assigning variable cf");
        } else {
          current_statement__ = 61;
          assign(cf, nil_index_list(), cf_par, "assigning variable cf");
        }
      }
      current_statement__ = 103;
      if (trend) {
        current_statement__ = 83;
        assign(cf, nil_index_list(), stan::math::exp(multiply(X, beta)),
          "assigning variable cf");
        current_statement__ = 86;
        for (int b = 1; b <= nyr; ++b) {
          current_statement__ = 84;
          assign(cf_yr,
            cons_list(index_min_max(1, nage),
              cons_list(index_uni(b), nil_index_list())),
            elt_multiply(cf,
              rvalue(cf_trend,
                cons_list(index_omni(),
                  cons_list(index_uni(b), nil_index_list())), "cf_trend")),
            "assigning variable cf_yr");}
        current_statement__ = 101;
        for (int k = 1; k <= nbias; ++k) {
          current_statement__ = 91;
          for (int b = 1; b <= nyr; ++b) {
            current_statement__ = 89;
            for (int a = 1; a <= nage; ++a) {
              current_statement__ = 87;
              assign(inc_yr,
                cons_list(index_uni(a),
                  cons_list(index_uni(b),
                    cons_list(index_uni(k), nil_index_list()))),
                (rvalue(inc,
                   cons_list(index_uni(a),
                     cons_list(index_uni(k), nil_index_list())), "inc") *
                  rvalue(inc_trend,
                    cons_list(index_uni(a),
                      cons_list(index_uni(b), nil_index_list())),
                    "inc_trend")), "assigning variable inc_yr");}}
          current_statement__ = 99;
          for (int b = 1; b <= nyr; ++b) {
            current_statement__ = 92;
            assign(state_probs_yr,
              cons_list(index_uni(1),
                cons_list(index_uni(b),
                  cons_list(index_uni(k),
                    cons_list(index_uni(1), nil_index_list())))), 1,
              "assigning variable state_probs_yr");
            current_statement__ = 93;
            assign(state_probs_yr,
              cons_list(index_uni(1),
                cons_list(index_uni(b),
                  cons_list(index_uni(k),
                    cons_list(index_uni(2), nil_index_list())))), 0,
              "assigning variable state_probs_yr");
            current_statement__ = 94;
            assign(state_probs_yr,
              cons_list(index_uni(1),
                cons_list(index_uni(b),
                  cons_list(index_uni(k),
                    cons_list(index_uni(3), nil_index_list())))), 0,
              "assigning variable state_probs_yr");
            current_statement__ = 97;
            for (int a = 2; a <= (nage + 1); ++a) {
              current_statement__ = 95;
              assign(state_probs_yr,
                cons_list(index_uni(a),
                  cons_list(index_uni(b),
                    cons_list(index_uni(k),
                      cons_list(index_min_max(1, 3), nil_index_list())))),
                rep_row_vector(0, 3), "assigning variable state_probs_yr");}}
        }
      } else {
        current_statement__ = 81;
        for (int k = 1; k <= nbias; ++k) {
          current_statement__ = 77;
          assign(state_probs,
            cons_list(index_uni(1),
              cons_list(index_uni(k),
                cons_list(index_uni(1), nil_index_list()))), 1,
            "assigning variable state_probs");
          current_statement__ = 78;
          assign(state_probs,
            cons_list(index_uni(1),
              cons_list(index_uni(k),
                cons_list(index_uni(2), nil_index_list()))), 0,
            "assigning variable state_probs");
          current_statement__ = 79;
          assign(state_probs,
            cons_list(index_uni(1),
              cons_list(index_uni(k),
                cons_list(index_uni(3), nil_index_list()))), 0,
            "assigning variable state_probs");}
      }
      current_statement__ = 140;
      for (int a = 1; a <= nage; ++a) {
        current_statement__ = 137;
        if (trend) {
          current_statement__ = 135;
          for (int k = 1; k <= nbias; ++k) {
            current_statement__ = 127;
            if (logical_gt(a, 1)) {
              int y;
              y = std::numeric_limits<int>::min();
              
              current_statement__ = 125;
              for (int b = 2; b <= a; ++b) {
                current_statement__ = 120;
                y = ((nyr - a) + b);
                current_statement__ = 121;
                assign(P, nil_index_list(),
                  trans_probs(inc_yr[((b - 1) - 1)][((y - 1) - 1)][(k - 1)],
                    rvalue(cf_yr,
                      cons_list(index_uni((b - 1)),
                        cons_list(index_uni((y - 1)), nil_index_list())),
                      "cf_yr"), rem[((b - 1) - 1)], pstream__),
                  "assigning variable P");
                current_statement__ = 122;
                assign(tmp, nil_index_list(),
                  multiply(
                    rvalue(state_probs_yr,
                      cons_list(index_uni((b - 1)),
                        cons_list(index_uni((y - 1)),
                          cons_list(index_uni(k),
                            cons_list(index_min_max(1, 3), nil_index_list())))),
                      "state_probs_yr"), P), "assigning variable tmp");
                current_statement__ = 123;
                assign(state_probs_yr,
                  cons_list(index_uni(b),
                    cons_list(index_uni(y),
                      cons_list(index_uni(k),
                        cons_list(index_min_max(1, 3), nil_index_list())))),
                  tmp, "assigning variable state_probs_yr");}
            } 
            current_statement__ = 128;
            assign(P, nil_index_list(),
              trans_probs(inc_yr[(a - 1)][(nyr - 1)][(k - 1)],
                rvalue(cf_yr,
                  cons_list(index_uni(a),
                    cons_list(index_uni(nyr), nil_index_list())), "cf_yr"),
                rem[(a - 1)], pstream__), "assigning variable P");
            current_statement__ = 129;
            assign(inc_prob,
              cons_list(index_uni(a),
                cons_list(index_uni(k), nil_index_list())),
              bound_prob(
                (rvalue(P,
                   cons_list(index_uni(1),
                     cons_list(index_uni(2), nil_index_list())), "P") +
                  rvalue(P,
                    cons_list(index_uni(1),
                      cons_list(index_uni(3), nil_index_list())), "P")), pstream__),
              "assigning variable inc_prob");
            current_statement__ = 130;
            assign(prev_prob,
              cons_list(index_uni(a),
                cons_list(index_uni(k), nil_index_list())),
              (state_probs_yr[(a - 1)][(nyr - 1)][(k - 1)][(2 - 1)] /
                (state_probs_yr[(a - 1)][(nyr - 1)][(k - 1)][(1 - 1)] +
                  state_probs_yr[(a - 1)][(nyr - 1)][(k - 1)][(2 - 1)])),
              "assigning variable prev_prob");
            current_statement__ = 132;
            if (logical_eq(k, 1)) {
              current_statement__ = 131;
              assign(mort_prob, cons_list(index_uni(a), nil_index_list()),
                ((rvalue(P,
                    cons_list(index_uni(1),
                      cons_list(index_uni(3), nil_index_list())), "P") *
                   (1 -
                     rvalue(prev_prob,
                       cons_list(index_uni(a),
                         cons_list(index_uni(1), nil_index_list())),
                       "prev_prob"))) +
                  (rvalue(P,
                     cons_list(index_uni(2),
                       cons_list(index_uni(3), nil_index_list())), "P") *
                    rvalue(prev_prob,
                      cons_list(index_uni(a),
                        cons_list(index_uni(1), nil_index_list())),
                      "prev_prob"))), "assigning variable mort_prob");
            } 
            current_statement__ = 133;
            assign(cf_prob, cons_list(index_uni(a), nil_index_list()),
              bound_prob(
                rvalue(P,
                  cons_list(index_uni(2),
                    cons_list(index_uni(3), nil_index_list())), "P"), pstream__),
              "assigning variable cf_prob");}
        } else {
          current_statement__ = 117;
          for (int k = 1; k <= nbias; ++k) {
            current_statement__ = 104;
            assign(P, nil_index_list(),
              trans_probs(
                rvalue(inc,
                  cons_list(index_uni(a),
                    cons_list(index_uni(k), nil_index_list())), "inc"),
                cf[(a - 1)], rem[(a - 1)], pstream__), "assigning variable P");
            current_statement__ = 105;
            assign(inc_prob,
              cons_list(index_uni(a),
                cons_list(index_uni(k), nil_index_list())),
              bound_prob(
                (rvalue(P,
                   cons_list(index_uni(1),
                     cons_list(index_uni(2), nil_index_list())), "P") +
                  rvalue(P,
                    cons_list(index_uni(1),
                      cons_list(index_uni(3), nil_index_list())), "P")), pstream__),
              "assigning variable inc_prob");
            current_statement__ = 107;
            if (logical_gt(a, 1)) {
              current_statement__ = 106;
              assign(prev_prob,
                cons_list(index_uni(a),
                  cons_list(index_uni(k), nil_index_list())),
                (state_probs[(a - 1)][(k - 1)][(2 - 1)] /
                  (state_probs[(a - 1)][(k - 1)][(1 - 1)] +
                    state_probs[(a - 1)][(k - 1)][(2 - 1)])),
                "assigning variable prev_prob");
            } 
            current_statement__ = 108;
            assign(tmp, nil_index_list(),
              multiply(
                rvalue(state_probs,
                  cons_list(index_uni(a),
                    cons_list(index_uni(k),
                      cons_list(index_min_max(1, 3), nil_index_list()))),
                  "state_probs"), P), "assigning variable tmp");
            current_statement__ = 109;
            assign(state_probs,
              cons_list(index_uni((a + 1)),
                cons_list(index_uni(k),
                  cons_list(index_min_max(1, 3), nil_index_list()))), tmp,
              "assigning variable state_probs");
            current_statement__ = 115;
            if (logical_eq(k, 1)) {
              current_statement__ = 110;
              assign(mort_prob, cons_list(index_uni(a), nil_index_list()),
                ((rvalue(P,
                    cons_list(index_uni(1),
                      cons_list(index_uni(3), nil_index_list())), "P") *
                   (1 -
                     rvalue(prev_prob,
                       cons_list(index_uni(a),
                         cons_list(index_uni(1), nil_index_list())),
                       "prev_prob"))) +
                  (rvalue(P,
                     cons_list(index_uni(2),
                       cons_list(index_uni(3), nil_index_list())), "P") *
                    rvalue(prev_prob,
                      cons_list(index_uni(a),
                        cons_list(index_uni(1), nil_index_list())),
                      "prev_prob"))), "assigning variable mort_prob");
              current_statement__ = 111;
              assign(cf_prob, cons_list(index_uni(a), nil_index_list()),
                bound_prob(
                  rvalue(P,
                    cons_list(index_uni(2),
                      cons_list(index_uni(3), nil_index_list())), "P"), pstream__),
                "assigning variable cf_prob");
              current_statement__ = 113;
              if (remission) {
                current_statement__ = 112;
                assign(rem_prob, cons_list(index_uni(a), nil_index_list()),
                  rvalue(P,
                    cons_list(index_uni(2),
                      cons_list(index_uni(1), nil_index_list())), "P"),
                  "assigning variable rem_prob");
              } 
            } }
        }
        current_statement__ = 138;
        assign(mort_prob, cons_list(index_uni(a), nil_index_list()),
          bound_prob(mort_prob[(a - 1)], pstream__),
          "assigning variable mort_prob");}
      current_statement__ = 13;
      for (int sym1__ = 1; sym1__ <= nage; ++sym1__) {
        current_statement__ = 13;
        current_statement__ = 13;
        check_greater_or_equal(function__, "cf[sym1__]", cf[(sym1__ - 1)], 0);
      }
      current_statement__ = 14;
      for (int sym1__ = 1; sym1__ <= dcf_1dim__; ++sym1__) {
        current_statement__ = 14;
        current_statement__ = 14;
        check_greater_or_equal(function__, "dcf[sym1__]", dcf[(sym1__ - 1)],
                               0);}
      current_statement__ = 15;
      for (int sym1__ = 1; sym1__ <= nage; ++sym1__) {
        current_statement__ = 15;
        for (int sym2__ = 1; sym2__ <= nbias; ++sym2__) {
          current_statement__ = 15;
          current_statement__ = 15;
          check_greater_or_equal(function__, "inc[sym1__, sym2__]",
                                 rvalue(inc,
                                   cons_list(index_uni(sym1__),
                                     cons_list(index_uni(sym2__),
                                       nil_index_list())), "inc"), 0);}}
      current_statement__ = 16;
      for (int sym1__ = 1; sym1__ <= nage; ++sym1__) {
        current_statement__ = 16;
        for (int sym2__ = 1; sym2__ <= nbias; ++sym2__) {
          current_statement__ = 16;
          current_statement__ = 16;
          check_greater_or_equal(function__, "inc_prob[sym1__, sym2__]",
                                 rvalue(inc_prob,
                                   cons_list(index_uni(sym1__),
                                     cons_list(index_uni(sym2__),
                                       nil_index_list())), "inc_prob"), 0);}}
      current_statement__ = 16;
      for (int sym1__ = 1; sym1__ <= nage; ++sym1__) {
        current_statement__ = 16;
        for (int sym2__ = 1; sym2__ <= nbias; ++sym2__) {
          current_statement__ = 16;
          current_statement__ = 16;
          check_less_or_equal(function__, "inc_prob[sym1__, sym2__]",
                              rvalue(inc_prob,
                                cons_list(index_uni(sym1__),
                                  cons_list(index_uni(sym2__),
                                    nil_index_list())), "inc_prob"), 1);}}
      current_statement__ = 17;
      for (int sym1__ = 1; sym1__ <= nage; ++sym1__) {
        current_statement__ = 17;
        current_statement__ = 17;
        check_greater_or_equal(function__, "rem[sym1__]", rem[(sym1__ - 1)],
                               0);}
      current_statement__ = 18;
      for (int sym1__ = 1; sym1__ <= rem_prob_1dim__; ++sym1__) {
        current_statement__ = 18;
        current_statement__ = 18;
        check_greater_or_equal(function__, "rem_prob[sym1__]",
                               rem_prob[(sym1__ - 1)], 0);}
      current_statement__ = 18;
      for (int sym1__ = 1; sym1__ <= rem_prob_1dim__; ++sym1__) {
        current_statement__ = 18;
        current_statement__ = 18;
        check_less_or_equal(function__, "rem_prob[sym1__]",
                            rem_prob[(sym1__ - 1)], 1);}
      current_statement__ = 19;
      for (int sym1__ = 1; sym1__ <= nage; ++sym1__) {
        current_statement__ = 19;
        current_statement__ = 19;
        check_greater_or_equal(function__, "cf_prob[sym1__]",
                               cf_prob[(sym1__ - 1)], 0);}
      current_statement__ = 19;
      for (int sym1__ = 1; sym1__ <= nage; ++sym1__) {
        current_statement__ = 19;
        current_statement__ = 19;
        check_less_or_equal(function__, "cf_prob[sym1__]",
                            cf_prob[(sym1__ - 1)], 1);}
      current_statement__ = 22;
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        current_statement__ = 22;
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          current_statement__ = 22;
          current_statement__ = 22;
          check_greater_or_equal(function__, "P[sym1__, sym2__]",
                                 rvalue(P,
                                   cons_list(index_uni(sym1__),
                                     cons_list(index_uni(sym2__),
                                       nil_index_list())), "P"), 0);}}
      current_statement__ = 22;
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        current_statement__ = 22;
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          current_statement__ = 22;
          current_statement__ = 22;
          check_less_or_equal(function__, "P[sym1__, sym2__]",
                              rvalue(P,
                                cons_list(index_uni(sym1__),
                                  cons_list(index_uni(sym2__),
                                    nil_index_list())), "P"), 1);}}
      current_statement__ = 23;
      for (int sym1__ = 1; sym1__ <= nage; ++sym1__) {
        current_statement__ = 23;
        for (int sym2__ = 1; sym2__ <= nbias; ++sym2__) {
          current_statement__ = 23;
          current_statement__ = 23;
          check_greater_or_equal(function__, "prev_prob[sym1__, sym2__]",
                                 rvalue(prev_prob,
                                   cons_list(index_uni(sym1__),
                                     cons_list(index_uni(sym2__),
                                       nil_index_list())), "prev_prob"), 0);}
      }
      current_statement__ = 24;
      for (int sym1__ = 1; sym1__ <= nage; ++sym1__) {
        current_statement__ = 24;
        current_statement__ = 24;
        check_greater_or_equal(function__, "mort_prob[sym1__]",
                               mort_prob[(sym1__ - 1)], 0);}
      current_statement__ = 25;
      for (int sym1__ = 1; sym1__ <= cf_yr_1dim__; ++sym1__) {
        current_statement__ = 25;
        for (int sym2__ = 1; sym2__ <= cf_yr_2dim__; ++sym2__) {
          current_statement__ = 25;
          current_statement__ = 25;
          check_greater_or_equal(function__, "cf_yr[sym1__, sym2__]",
                                 rvalue(cf_yr,
                                   cons_list(index_uni(sym1__),
                                     cons_list(index_uni(sym2__),
                                       nil_index_list())), "cf_yr"), 0);}}
      current_statement__ = 26;
      for (int sym1__ = 1; sym1__ <= inc_yr_1dim__; ++sym1__) {
        current_statement__ = 26;
        for (int sym2__ = 1; sym2__ <= inc_yr_2dim__; ++sym2__) {
          current_statement__ = 26;
          for (int sym3__ = 1; sym3__ <= nbias; ++sym3__) {
            current_statement__ = 26;
            current_statement__ = 26;
            check_greater_or_equal(function__,
                                   "inc_yr[sym1__, sym2__, sym3__]",
                                   inc_yr[(sym1__ - 1)][(sym2__ - 1)][
                                   (sym3__ - 1)], 0);}}}
      current_statement__ = 28;
      current_statement__ = 28;
      check_greater_or_equal(function__, "lambda_cf_use", lambda_cf_use, 0);
      current_statement__ = 29;
      current_statement__ = 29;
      check_greater_or_equal(function__, "lambda_inc_use", lambda_inc_use, 0);
      current_statement__ = 30;
      current_statement__ = 30;
      check_greater_or_equal(function__, "lambda_rem_use", lambda_rem_use, 0);
      {
        current_statement__ = 156;
        lp_accum__.add(
          binomial_lpmf<propto__>(mort_num, mort_denom, mort_prob));
        current_statement__ = 157;
        lp_accum__.add(
          binomial_lpmf<propto__>(inc_num, inc_denom,
            rvalue(inc_prob,
              cons_list(index_min_max(1, nage),
                cons_list(index_uni(incdata_ind), nil_index_list())),
              "inc_prob")));
        current_statement__ = 158;
        lp_accum__.add(
          binomial_lpmf<propto__>(prev_num, prev_denom,
            rvalue(prev_prob,
              cons_list(index_min_max(1, nage),
                cons_list(index_uni(prevdata_ind), nil_index_list())),
              "prev_prob")));
        current_statement__ = 161;
        if (remission) {
          current_statement__ = 159;
          lp_accum__.add(
            binomial_lpmf<propto__>(rem_num, rem_denom, rem_prob));
        } 
        current_statement__ = 177;
        if (smooth_cf) {
          current_statement__ = 173;
          if (logical_negation(const_cf)) {
            current_statement__ = 168;
            for (int i = 1; i <= (K - 2); ++i) {
              current_statement__ = 166;
              lp_accum__.add(
                normal_lpdf<propto__>(beta[(i - 1)], 0, lambda_cf_use));}
            current_statement__ = 171;
            for (int i = (K - 1); i <= K; ++i) {
              current_statement__ = 169;
              lp_accum__.add(normal_lpdf<propto__>(beta[(i - 1)], 0, 100));}
          } 
          current_statement__ = 175;
          if (logical_negation(scf_isfixed)) {
            current_statement__ = 174;
            lp_accum__.add(
              gamma_lpdf<propto__>(lambda_cf[(1 - 1)], 2, sprior[(2 - 1)]));
          } 
        } else {
          current_statement__ = 164;
          for (int a = 1; a <= nage; ++a) {
            current_statement__ = 162;
            lp_accum__.add(
              gamma_lpdf<propto__>(cf_par[(a - 1)], cf_prior[(1 - 1)],
                cf_prior[(2 - 1)]));}
        }
        current_statement__ = 180;
        if (increasing_cf) {
          current_statement__ = 178;
          lp_accum__.add(
            gamma_lpdf<propto__>(cfbase[(1 - 1)], cf_prior[(1 - 1)],
              cf_prior[(2 - 1)]));
        } 
        current_statement__ = 194;
        if (smooth_inc) {
          current_statement__ = 187;
          for (int i = 1; i <= (K - 2); ++i) {
            current_statement__ = 185;
            lp_accum__.add(
              normal_lpdf<propto__>(beta_inc[(i - 1)], 0, lambda_inc_use));}
          current_statement__ = 190;
          for (int i = (K - 1); i <= K; ++i) {
            current_statement__ = 188;
            lp_accum__.add(normal_lpdf<propto__>(beta_inc[(i - 1)], 0, 100));
          }
          current_statement__ = 192;
          if (logical_negation(sinc_isfixed)) {
            current_statement__ = 191;
            lp_accum__.add(
              gamma_lpdf<propto__>(lambda_inc[(1 - 1)], 2, sprior[(1 - 1)]));
          } 
        } else {
          current_statement__ = 183;
          for (int a = 1; a <= nage; ++a) {
            current_statement__ = 181;
            lp_accum__.add(
              gamma_lpdf<propto__>(inc_par[(a - 1)], inc_prior[(1 - 1)],
                inc_prior[(2 - 1)]));}
        }
        current_statement__ = 212;
        if (remission) {
          current_statement__ = 210;
          if (smooth_rem) {
            current_statement__ = 203;
            for (int i = 1; i <= (K - 2); ++i) {
              current_statement__ = 201;
              lp_accum__.add(
                normal_lpdf<propto__>(beta_rem[(i - 1)], 0, lambda_rem_use));
            }
            current_statement__ = 206;
            for (int i = (K - 1); i <= K; ++i) {
              current_statement__ = 204;
              lp_accum__.add(normal_lpdf<propto__>(beta_rem[(i - 1)], 0, 100));
            }
            current_statement__ = 208;
            if (logical_negation(srem_isfixed)) {
              current_statement__ = 207;
              lp_accum__.add(
                gamma_lpdf<propto__>(lambda_rem[(1 - 1)], 2, sprior[(3 - 1)]));
            } 
          } else {
            current_statement__ = 200;
            if (const_rem) {
              current_statement__ = 199;
              lp_accum__.add(
                gamma_lpdf<propto__>(rem_par[(1 - 1)], rem_prior[(1 - 1)],
                  rem_prior[(2 - 1)]));
            } else {
              current_statement__ = 197;
              for (int a = 1; a <= nage; ++a) {
                current_statement__ = 195;
                lp_accum__.add(
                  gamma_lpdf<propto__>(rem_par[(a - 1)], rem_prior[(1 - 1)],
                    rem_prior[(2 - 1)]));}
            }
          }
        } 
        current_statement__ = 215;
        if (logical_eq(nbias, 2)) {
          current_statement__ = 213;
          lp_accum__.add(normal_lpdf<propto__>(bias_loghr, 0, 1));
        } 
        current_statement__ = 218;
        if (prev_zero) {
          current_statement__ = 216;
          lp_accum__.add(beta_lpdf<propto__>(prevzero[(1 - 1)], 2, 2));
        } 
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr>
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.resize(0);
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    static const char* function__ = "model_disbayes_namespace::write_array";
(void) function__;  // suppress unused var warning
    (void) function__;  // suppress unused var warning
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    
    try {
      Eigen::Matrix<double, -1, 1> inc_par;
      inc_par = Eigen::Matrix<double, -1, 1>(inc_par_1dim__);
      stan::math::fill(inc_par, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 1;
      inc_par = in__.vector(inc_par_1dim__);
      current_statement__ = 1;
      for (int sym1__ = 1; sym1__ <= inc_par_1dim__; ++sym1__) {
        current_statement__ = 1;
        assign(inc_par, cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_constrain(inc_par[(sym1__ - 1)], 0),
          "assigning variable inc_par");}
      Eigen::Matrix<double, -1, 1> cf_par;
      cf_par = Eigen::Matrix<double, -1, 1>(cf_par_1dim__);
      stan::math::fill(cf_par, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 2;
      cf_par = in__.vector(cf_par_1dim__);
      current_statement__ = 2;
      for (int sym1__ = 1; sym1__ <= cf_par_1dim__; ++sym1__) {
        current_statement__ = 2;
        assign(cf_par, cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_constrain(cf_par[(sym1__ - 1)], 0),
          "assigning variable cf_par");}
      Eigen::Matrix<double, -1, 1> rem_par;
      rem_par = Eigen::Matrix<double, -1, 1>(rem_par_1dim__);
      stan::math::fill(rem_par, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 3;
      rem_par = in__.vector(rem_par_1dim__);
      current_statement__ = 3;
      for (int sym1__ = 1; sym1__ <= rem_par_1dim__; ++sym1__) {
        current_statement__ = 3;
        assign(rem_par, cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_constrain(rem_par[(sym1__ - 1)], 0),
          "assigning variable rem_par");}
      Eigen::Matrix<double, -1, 1> beta;
      beta = Eigen::Matrix<double, -1, 1>(beta_1dim__);
      stan::math::fill(beta, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 4;
      beta = in__.vector(beta_1dim__);
      Eigen::Matrix<double, -1, 1> lambda_cf;
      lambda_cf = Eigen::Matrix<double, -1, 1>(lambda_cf_1dim__);
      stan::math::fill(lambda_cf, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 5;
      lambda_cf = in__.vector(lambda_cf_1dim__);
      current_statement__ = 5;
      for (int sym1__ = 1; sym1__ <= lambda_cf_1dim__; ++sym1__) {
        current_statement__ = 5;
        assign(lambda_cf, cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_constrain(lambda_cf[(sym1__ - 1)], 0),
          "assigning variable lambda_cf");}
      Eigen::Matrix<double, -1, 1> lambda_inc;
      lambda_inc = Eigen::Matrix<double, -1, 1>(lambda_inc_1dim__);
      stan::math::fill(lambda_inc, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 6;
      lambda_inc = in__.vector(lambda_inc_1dim__);
      current_statement__ = 6;
      for (int sym1__ = 1; sym1__ <= lambda_inc_1dim__; ++sym1__) {
        current_statement__ = 6;
        assign(lambda_inc, cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_constrain(lambda_inc[(sym1__ - 1)], 0),
          "assigning variable lambda_inc");}
      Eigen::Matrix<double, -1, 1> beta_inc;
      beta_inc = Eigen::Matrix<double, -1, 1>(beta_inc_1dim__);
      stan::math::fill(beta_inc, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 7;
      beta_inc = in__.vector(beta_inc_1dim__);
      Eigen::Matrix<double, -1, 1> lambda_rem;
      lambda_rem = Eigen::Matrix<double, -1, 1>(lambda_rem_1dim__);
      stan::math::fill(lambda_rem, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 8;
      lambda_rem = in__.vector(lambda_rem_1dim__);
      current_statement__ = 8;
      for (int sym1__ = 1; sym1__ <= lambda_rem_1dim__; ++sym1__) {
        current_statement__ = 8;
        assign(lambda_rem, cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_constrain(lambda_rem[(sym1__ - 1)], 0),
          "assigning variable lambda_rem");}
      Eigen::Matrix<double, -1, 1> beta_rem;
      beta_rem = Eigen::Matrix<double, -1, 1>(beta_rem_1dim__);
      stan::math::fill(beta_rem, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 9;
      beta_rem = in__.vector(beta_rem_1dim__);
      Eigen::Matrix<double, -1, 1> prevzero;
      prevzero = Eigen::Matrix<double, -1, 1>(prev_zero);
      stan::math::fill(prevzero, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 10;
      prevzero = in__.vector(prev_zero);
      current_statement__ = 10;
      for (int sym1__ = 1; sym1__ <= prev_zero; ++sym1__) {
        current_statement__ = 10;
        assign(prevzero, cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lub_constrain(prevzero[(sym1__ - 1)], 0, 1),
          "assigning variable prevzero");}
      Eigen::Matrix<double, -1, 1> bias_loghr;
      bias_loghr = Eigen::Matrix<double, -1, 1>(bias_loghr_1dim__);
      stan::math::fill(bias_loghr, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 11;
      bias_loghr = in__.vector(bias_loghr_1dim__);
      Eigen::Matrix<double, -1, 1> cfbase;
      cfbase = Eigen::Matrix<double, -1, 1>(cfbase_1dim__);
      stan::math::fill(cfbase, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 12;
      cfbase = in__.vector(cfbase_1dim__);
      current_statement__ = 12;
      for (int sym1__ = 1; sym1__ <= cfbase_1dim__; ++sym1__) {
        current_statement__ = 12;
        assign(cfbase, cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_constrain(cfbase[(sym1__ - 1)], 0),
          "assigning variable cfbase");}
      Eigen::Matrix<double, -1, 1> cf;
      cf = Eigen::Matrix<double, -1, 1>(nage);
      stan::math::fill(cf, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, 1> dcf;
      dcf = Eigen::Matrix<double, -1, 1>(dcf_1dim__);
      stan::math::fill(dcf, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, -1> inc;
      inc = Eigen::Matrix<double, -1, -1>(nage, nbias);
      stan::math::fill(inc, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, -1> inc_prob;
      inc_prob = Eigen::Matrix<double, -1, -1>(nage, nbias);
      stan::math::fill(inc_prob, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, 1> rem;
      rem = Eigen::Matrix<double, -1, 1>(nage);
      stan::math::fill(rem, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, 1> rem_prob;
      rem_prob = Eigen::Matrix<double, -1, 1>(rem_prob_1dim__);
      stan::math::fill(rem_prob, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, 1> cf_prob;
      cf_prob = Eigen::Matrix<double, -1, 1>(nage);
      stan::math::fill(cf_prob, std::numeric_limits<double>::quiet_NaN());
      
      std::vector<std::vector<Eigen::Matrix<double, 1, -1>>> state_probs;
      state_probs = std::vector<std::vector<Eigen::Matrix<double, 1, -1>>>(state_probs_1dim__, std::vector<Eigen::Matrix<double, 1, -1>>(nbias, Eigen::Matrix<double, 1, -1>(3)));
      stan::math::fill(state_probs, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, 1, -1> tmp;
      tmp = Eigen::Matrix<double, 1, -1>(3);
      stan::math::fill(tmp, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, -1> P;
      P = Eigen::Matrix<double, -1, -1>(3, 3);
      stan::math::fill(P, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, -1> prev_prob;
      prev_prob = Eigen::Matrix<double, -1, -1>(nage, nbias);
      stan::math::fill(prev_prob, std::numeric_limits<double>::quiet_NaN());
      
      std::vector<double> mort_prob;
      mort_prob = std::vector<double>(nage, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, -1> cf_yr;
      cf_yr = Eigen::Matrix<double, -1, -1>(cf_yr_1dim__, cf_yr_2dim__);
      stan::math::fill(cf_yr, std::numeric_limits<double>::quiet_NaN());
      
      std::vector<std::vector<std::vector<double>>> inc_yr;
      inc_yr = std::vector<std::vector<std::vector<double>>>(inc_yr_1dim__, std::vector<std::vector<double>>(inc_yr_2dim__, std::vector<double>(nbias, std::numeric_limits<double>::quiet_NaN())));
      
      std::vector<std::vector<std::vector<Eigen::Matrix<double, 1, -1>>>> state_probs_yr;
      state_probs_yr = std::vector<std::vector<std::vector<Eigen::Matrix<double, 1, -1>>>>(state_probs_yr_1dim__, std::vector<std::vector<Eigen::Matrix<double, 1, -1>>>(state_probs_yr_2dim__, std::vector<Eigen::Matrix<double, 1, -1>>(nbias, Eigen::Matrix<double, 1, -1>(3))));
      stan::math::fill(state_probs_yr, std::numeric_limits<double>::quiet_NaN());
      
      double lambda_cf_use;
      lambda_cf_use = std::numeric_limits<double>::quiet_NaN();
      
      double lambda_inc_use;
      lambda_inc_use = std::numeric_limits<double>::quiet_NaN();
      
      double lambda_rem_use;
      lambda_rem_use = std::numeric_limits<double>::quiet_NaN();
      
      for (int sym1__ = 1; sym1__ <= inc_par_1dim__; ++sym1__) {
        vars__.emplace_back(inc_par[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= cf_par_1dim__; ++sym1__) {
        vars__.emplace_back(cf_par[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= rem_par_1dim__; ++sym1__) {
        vars__.emplace_back(rem_par[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= beta_1dim__; ++sym1__) {
        vars__.emplace_back(beta[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= lambda_cf_1dim__; ++sym1__) {
        vars__.emplace_back(lambda_cf[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= lambda_inc_1dim__; ++sym1__) {
        vars__.emplace_back(lambda_inc[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= beta_inc_1dim__; ++sym1__) {
        vars__.emplace_back(beta_inc[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= lambda_rem_1dim__; ++sym1__) {
        vars__.emplace_back(lambda_rem[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= beta_rem_1dim__; ++sym1__) {
        vars__.emplace_back(beta_rem[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= prev_zero; ++sym1__) {
        vars__.emplace_back(prevzero[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= bias_loghr_1dim__; ++sym1__) {
        vars__.emplace_back(bias_loghr[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= cfbase_1dim__; ++sym1__) {
        vars__.emplace_back(cfbase[(sym1__ - 1)]);}
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      current_statement__ = 33;
      if ((primitive_value(scf_isfixed) || primitive_value(
          logical_negation(smooth_cf)))) {
        current_statement__ = 32;
        lambda_cf_use = lambda_cf_fixed;
      } else {
        current_statement__ = 31;
        lambda_cf_use = lambda_cf[(1 - 1)];
      }
      current_statement__ = 36;
      if ((primitive_value(sinc_isfixed) || primitive_value(
          logical_negation(smooth_inc)))) {
        current_statement__ = 35;
        lambda_inc_use = lambda_inc_fixed;
      } else {
        current_statement__ = 34;
        lambda_inc_use = lambda_inc[(1 - 1)];
      }
      current_statement__ = 39;
      if ((primitive_value(srem_isfixed) || primitive_value(
          logical_negation(smooth_rem)))) {
        current_statement__ = 38;
        lambda_rem_use = lambda_rem_fixed;
      } else {
        current_statement__ = 37;
        lambda_rem_use = lambda_rem[(1 - 1)];
      }
      current_statement__ = 42;
      if (smooth_inc) {
        current_statement__ = 41;
        assign(inc,
          cons_list(index_min_max(1, nage),
            cons_list(index_uni(1), nil_index_list())),
          stan::math::exp(multiply(X, beta_inc)), "assigning variable inc");
      } else {
        current_statement__ = 40;
        assign(inc,
          cons_list(index_min_max(1, nage),
            cons_list(index_uni(1), nil_index_list())), inc_par,
          "assigning variable inc");
      }
      current_statement__ = 45;
      if (logical_gt(nbias, 1)) {
        current_statement__ = 43;
        assign(inc,
          cons_list(index_min_max(1, nage),
            cons_list(index_uni(2), nil_index_list())),
          stan::math::exp(
            add(
              stan::math::log(
                stan::model::deep_copy(
                  rvalue(inc,
                    cons_list(index_min_max(1, nage),
                      cons_list(index_uni(1), nil_index_list())), "inc"))),
              bias_loghr[(1 - 1)])), "assigning variable inc");
      } 
      current_statement__ = 55;
      if (remission) {
        current_statement__ = 53;
        if (const_rem) {
          current_statement__ = 51;
          for (int a = 1; a <= nage; ++a) {
            current_statement__ = 50;
            assign(rem, cons_list(index_uni(a), nil_index_list()),
              rem_par[(1 - 1)], "assigning variable rem");}
        } else {
          current_statement__ = 49;
          if (smooth_rem) {
            current_statement__ = 48;
            assign(rem, nil_index_list(),
              stan::math::exp(multiply(X, beta_rem)),
              "assigning variable rem");
          } else {
            current_statement__ = 47;
            assign(rem, nil_index_list(), rem_par, "assigning variable rem");
          }
        }
      } else {
        current_statement__ = 46;
        assign(rem, nil_index_list(), rep_vector(0, nage),
          "assigning variable rem");
      }
      current_statement__ = 60;
      for (int k = 1; k <= nbias; ++k) {
        current_statement__ = 58;
        if ((primitive_value(logical_gt(prev_denom[(1 - 1)], 0)) &&
            primitive_value((primitive_value(
            logical_gt(prev_num[(1 - 1)], 0)) || primitive_value(
            prev_zero))))) {
          current_statement__ = 57;
          assign(prev_prob,
            cons_list(index_uni(1),
              cons_list(index_uni(k), nil_index_list())), prevzero[(1 - 1)],
            "assigning variable prev_prob");
        } else {
          current_statement__ = 56;
          assign(prev_prob,
            cons_list(index_uni(1),
              cons_list(index_uni(k), nil_index_list())), 0,
            "assigning variable prev_prob");
        }}
      current_statement__ = 76;
      if (increasing_cf) {
        current_statement__ = 67;
        for (int a = 1; a <= (eqage - 1); ++a) {
          current_statement__ = 65;
          assign(cf, cons_list(index_uni(a), nil_index_list()),
            cfbase[(1 - 1)], "assigning variable cf");}
        current_statement__ = 71;
        if (logical_negation(const_cf)) {
          current_statement__ = 69;
          assign(dcf, nil_index_list(), stan::math::exp(multiply(X, beta)),
            "assigning variable dcf");
        } else {
          current_statement__ = 68;
          assign(dcf, nil_index_list(), rep_vector(0, nage),
            "assigning variable dcf");
        }
        current_statement__ = 74;
        for (int a = eqage; a <= nage; ++a) {
          current_statement__ = 72;
          assign(cf, cons_list(index_uni(a), nil_index_list()),
            (cf[((a - 1) - 1)] + dcf[(a - 1)]), "assigning variable cf");}
      } else {
        current_statement__ = 63;
        if (smooth_cf) {
          current_statement__ = 62;
          assign(cf, nil_index_list(), stan::math::exp(multiply(X, beta)),
            "assigning variable cf");
        } else {
          current_statement__ = 61;
          assign(cf, nil_index_list(), cf_par, "assigning variable cf");
        }
      }
      current_statement__ = 103;
      if (trend) {
        current_statement__ = 83;
        assign(cf, nil_index_list(), stan::math::exp(multiply(X, beta)),
          "assigning variable cf");
        current_statement__ = 86;
        for (int b = 1; b <= nyr; ++b) {
          current_statement__ = 84;
          assign(cf_yr,
            cons_list(index_min_max(1, nage),
              cons_list(index_uni(b), nil_index_list())),
            elt_multiply(cf,
              rvalue(cf_trend,
                cons_list(index_omni(),
                  cons_list(index_uni(b), nil_index_list())), "cf_trend")),
            "assigning variable cf_yr");}
        current_statement__ = 101;
        for (int k = 1; k <= nbias; ++k) {
          current_statement__ = 91;
          for (int b = 1; b <= nyr; ++b) {
            current_statement__ = 89;
            for (int a = 1; a <= nage; ++a) {
              current_statement__ = 87;
              assign(inc_yr,
                cons_list(index_uni(a),
                  cons_list(index_uni(b),
                    cons_list(index_uni(k), nil_index_list()))),
                (rvalue(inc,
                   cons_list(index_uni(a),
                     cons_list(index_uni(k), nil_index_list())), "inc") *
                  rvalue(inc_trend,
                    cons_list(index_uni(a),
                      cons_list(index_uni(b), nil_index_list())),
                    "inc_trend")), "assigning variable inc_yr");}}
          current_statement__ = 99;
          for (int b = 1; b <= nyr; ++b) {
            current_statement__ = 92;
            assign(state_probs_yr,
              cons_list(index_uni(1),
                cons_list(index_uni(b),
                  cons_list(index_uni(k),
                    cons_list(index_uni(1), nil_index_list())))), 1,
              "assigning variable state_probs_yr");
            current_statement__ = 93;
            assign(state_probs_yr,
              cons_list(index_uni(1),
                cons_list(index_uni(b),
                  cons_list(index_uni(k),
                    cons_list(index_uni(2), nil_index_list())))), 0,
              "assigning variable state_probs_yr");
            current_statement__ = 94;
            assign(state_probs_yr,
              cons_list(index_uni(1),
                cons_list(index_uni(b),
                  cons_list(index_uni(k),
                    cons_list(index_uni(3), nil_index_list())))), 0,
              "assigning variable state_probs_yr");
            current_statement__ = 97;
            for (int a = 2; a <= (nage + 1); ++a) {
              current_statement__ = 95;
              assign(state_probs_yr,
                cons_list(index_uni(a),
                  cons_list(index_uni(b),
                    cons_list(index_uni(k),
                      cons_list(index_min_max(1, 3), nil_index_list())))),
                rep_row_vector(0, 3), "assigning variable state_probs_yr");}}
        }
      } else {
        current_statement__ = 81;
        for (int k = 1; k <= nbias; ++k) {
          current_statement__ = 77;
          assign(state_probs,
            cons_list(index_uni(1),
              cons_list(index_uni(k),
                cons_list(index_uni(1), nil_index_list()))), 1,
            "assigning variable state_probs");
          current_statement__ = 78;
          assign(state_probs,
            cons_list(index_uni(1),
              cons_list(index_uni(k),
                cons_list(index_uni(2), nil_index_list()))), 0,
            "assigning variable state_probs");
          current_statement__ = 79;
          assign(state_probs,
            cons_list(index_uni(1),
              cons_list(index_uni(k),
                cons_list(index_uni(3), nil_index_list()))), 0,
            "assigning variable state_probs");}
      }
      current_statement__ = 140;
      for (int a = 1; a <= nage; ++a) {
        current_statement__ = 137;
        if (trend) {
          current_statement__ = 135;
          for (int k = 1; k <= nbias; ++k) {
            current_statement__ = 127;
            if (logical_gt(a, 1)) {
              int y;
              y = std::numeric_limits<int>::min();
              
              current_statement__ = 125;
              for (int b = 2; b <= a; ++b) {
                current_statement__ = 120;
                y = ((nyr - a) + b);
                current_statement__ = 121;
                assign(P, nil_index_list(),
                  trans_probs(inc_yr[((b - 1) - 1)][((y - 1) - 1)][(k - 1)],
                    rvalue(cf_yr,
                      cons_list(index_uni((b - 1)),
                        cons_list(index_uni((y - 1)), nil_index_list())),
                      "cf_yr"), rem[((b - 1) - 1)], pstream__),
                  "assigning variable P");
                current_statement__ = 122;
                assign(tmp, nil_index_list(),
                  multiply(
                    rvalue(state_probs_yr,
                      cons_list(index_uni((b - 1)),
                        cons_list(index_uni((y - 1)),
                          cons_list(index_uni(k),
                            cons_list(index_min_max(1, 3), nil_index_list())))),
                      "state_probs_yr"), P), "assigning variable tmp");
                current_statement__ = 123;
                assign(state_probs_yr,
                  cons_list(index_uni(b),
                    cons_list(index_uni(y),
                      cons_list(index_uni(k),
                        cons_list(index_min_max(1, 3), nil_index_list())))),
                  tmp, "assigning variable state_probs_yr");}
            } 
            current_statement__ = 128;
            assign(P, nil_index_list(),
              trans_probs(inc_yr[(a - 1)][(nyr - 1)][(k - 1)],
                rvalue(cf_yr,
                  cons_list(index_uni(a),
                    cons_list(index_uni(nyr), nil_index_list())), "cf_yr"),
                rem[(a - 1)], pstream__), "assigning variable P");
            current_statement__ = 129;
            assign(inc_prob,
              cons_list(index_uni(a),
                cons_list(index_uni(k), nil_index_list())),
              bound_prob(
                (rvalue(P,
                   cons_list(index_uni(1),
                     cons_list(index_uni(2), nil_index_list())), "P") +
                  rvalue(P,
                    cons_list(index_uni(1),
                      cons_list(index_uni(3), nil_index_list())), "P")), pstream__),
              "assigning variable inc_prob");
            current_statement__ = 130;
            assign(prev_prob,
              cons_list(index_uni(a),
                cons_list(index_uni(k), nil_index_list())),
              (state_probs_yr[(a - 1)][(nyr - 1)][(k - 1)][(2 - 1)] /
                (state_probs_yr[(a - 1)][(nyr - 1)][(k - 1)][(1 - 1)] +
                  state_probs_yr[(a - 1)][(nyr - 1)][(k - 1)][(2 - 1)])),
              "assigning variable prev_prob");
            current_statement__ = 132;
            if (logical_eq(k, 1)) {
              current_statement__ = 131;
              assign(mort_prob, cons_list(index_uni(a), nil_index_list()),
                ((rvalue(P,
                    cons_list(index_uni(1),
                      cons_list(index_uni(3), nil_index_list())), "P") *
                   (1 -
                     rvalue(prev_prob,
                       cons_list(index_uni(a),
                         cons_list(index_uni(1), nil_index_list())),
                       "prev_prob"))) +
                  (rvalue(P,
                     cons_list(index_uni(2),
                       cons_list(index_uni(3), nil_index_list())), "P") *
                    rvalue(prev_prob,
                      cons_list(index_uni(a),
                        cons_list(index_uni(1), nil_index_list())),
                      "prev_prob"))), "assigning variable mort_prob");
            } 
            current_statement__ = 133;
            assign(cf_prob, cons_list(index_uni(a), nil_index_list()),
              bound_prob(
                rvalue(P,
                  cons_list(index_uni(2),
                    cons_list(index_uni(3), nil_index_list())), "P"), pstream__),
              "assigning variable cf_prob");}
        } else {
          current_statement__ = 117;
          for (int k = 1; k <= nbias; ++k) {
            current_statement__ = 104;
            assign(P, nil_index_list(),
              trans_probs(
                rvalue(inc,
                  cons_list(index_uni(a),
                    cons_list(index_uni(k), nil_index_list())), "inc"),
                cf[(a - 1)], rem[(a - 1)], pstream__), "assigning variable P");
            current_statement__ = 105;
            assign(inc_prob,
              cons_list(index_uni(a),
                cons_list(index_uni(k), nil_index_list())),
              bound_prob(
                (rvalue(P,
                   cons_list(index_uni(1),
                     cons_list(index_uni(2), nil_index_list())), "P") +
                  rvalue(P,
                    cons_list(index_uni(1),
                      cons_list(index_uni(3), nil_index_list())), "P")), pstream__),
              "assigning variable inc_prob");
            current_statement__ = 107;
            if (logical_gt(a, 1)) {
              current_statement__ = 106;
              assign(prev_prob,
                cons_list(index_uni(a),
                  cons_list(index_uni(k), nil_index_list())),
                (state_probs[(a - 1)][(k - 1)][(2 - 1)] /
                  (state_probs[(a - 1)][(k - 1)][(1 - 1)] +
                    state_probs[(a - 1)][(k - 1)][(2 - 1)])),
                "assigning variable prev_prob");
            } 
            current_statement__ = 108;
            assign(tmp, nil_index_list(),
              multiply(
                rvalue(state_probs,
                  cons_list(index_uni(a),
                    cons_list(index_uni(k),
                      cons_list(index_min_max(1, 3), nil_index_list()))),
                  "state_probs"), P), "assigning variable tmp");
            current_statement__ = 109;
            assign(state_probs,
              cons_list(index_uni((a + 1)),
                cons_list(index_uni(k),
                  cons_list(index_min_max(1, 3), nil_index_list()))), tmp,
              "assigning variable state_probs");
            current_statement__ = 115;
            if (logical_eq(k, 1)) {
              current_statement__ = 110;
              assign(mort_prob, cons_list(index_uni(a), nil_index_list()),
                ((rvalue(P,
                    cons_list(index_uni(1),
                      cons_list(index_uni(3), nil_index_list())), "P") *
                   (1 -
                     rvalue(prev_prob,
                       cons_list(index_uni(a),
                         cons_list(index_uni(1), nil_index_list())),
                       "prev_prob"))) +
                  (rvalue(P,
                     cons_list(index_uni(2),
                       cons_list(index_uni(3), nil_index_list())), "P") *
                    rvalue(prev_prob,
                      cons_list(index_uni(a),
                        cons_list(index_uni(1), nil_index_list())),
                      "prev_prob"))), "assigning variable mort_prob");
              current_statement__ = 111;
              assign(cf_prob, cons_list(index_uni(a), nil_index_list()),
                bound_prob(
                  rvalue(P,
                    cons_list(index_uni(2),
                      cons_list(index_uni(3), nil_index_list())), "P"), pstream__),
                "assigning variable cf_prob");
              current_statement__ = 113;
              if (remission) {
                current_statement__ = 112;
                assign(rem_prob, cons_list(index_uni(a), nil_index_list()),
                  rvalue(P,
                    cons_list(index_uni(2),
                      cons_list(index_uni(1), nil_index_list())), "P"),
                  "assigning variable rem_prob");
              } 
            } }
        }
        current_statement__ = 138;
        assign(mort_prob, cons_list(index_uni(a), nil_index_list()),
          bound_prob(mort_prob[(a - 1)], pstream__),
          "assigning variable mort_prob");}
      current_statement__ = 13;
      for (int sym1__ = 1; sym1__ <= nage; ++sym1__) {
        current_statement__ = 13;
        current_statement__ = 13;
        check_greater_or_equal(function__, "cf[sym1__]", cf[(sym1__ - 1)], 0);
      }
      current_statement__ = 14;
      for (int sym1__ = 1; sym1__ <= dcf_1dim__; ++sym1__) {
        current_statement__ = 14;
        current_statement__ = 14;
        check_greater_or_equal(function__, "dcf[sym1__]", dcf[(sym1__ - 1)],
                               0);}
      current_statement__ = 15;
      for (int sym1__ = 1; sym1__ <= nage; ++sym1__) {
        current_statement__ = 15;
        for (int sym2__ = 1; sym2__ <= nbias; ++sym2__) {
          current_statement__ = 15;
          current_statement__ = 15;
          check_greater_or_equal(function__, "inc[sym1__, sym2__]",
                                 rvalue(inc,
                                   cons_list(index_uni(sym1__),
                                     cons_list(index_uni(sym2__),
                                       nil_index_list())), "inc"), 0);}}
      current_statement__ = 16;
      for (int sym1__ = 1; sym1__ <= nage; ++sym1__) {
        current_statement__ = 16;
        for (int sym2__ = 1; sym2__ <= nbias; ++sym2__) {
          current_statement__ = 16;
          current_statement__ = 16;
          check_greater_or_equal(function__, "inc_prob[sym1__, sym2__]",
                                 rvalue(inc_prob,
                                   cons_list(index_uni(sym1__),
                                     cons_list(index_uni(sym2__),
                                       nil_index_list())), "inc_prob"), 0);}}
      current_statement__ = 16;
      for (int sym1__ = 1; sym1__ <= nage; ++sym1__) {
        current_statement__ = 16;
        for (int sym2__ = 1; sym2__ <= nbias; ++sym2__) {
          current_statement__ = 16;
          current_statement__ = 16;
          check_less_or_equal(function__, "inc_prob[sym1__, sym2__]",
                              rvalue(inc_prob,
                                cons_list(index_uni(sym1__),
                                  cons_list(index_uni(sym2__),
                                    nil_index_list())), "inc_prob"), 1);}}
      current_statement__ = 17;
      for (int sym1__ = 1; sym1__ <= nage; ++sym1__) {
        current_statement__ = 17;
        current_statement__ = 17;
        check_greater_or_equal(function__, "rem[sym1__]", rem[(sym1__ - 1)],
                               0);}
      current_statement__ = 18;
      for (int sym1__ = 1; sym1__ <= rem_prob_1dim__; ++sym1__) {
        current_statement__ = 18;
        current_statement__ = 18;
        check_greater_or_equal(function__, "rem_prob[sym1__]",
                               rem_prob[(sym1__ - 1)], 0);}
      current_statement__ = 18;
      for (int sym1__ = 1; sym1__ <= rem_prob_1dim__; ++sym1__) {
        current_statement__ = 18;
        current_statement__ = 18;
        check_less_or_equal(function__, "rem_prob[sym1__]",
                            rem_prob[(sym1__ - 1)], 1);}
      current_statement__ = 19;
      for (int sym1__ = 1; sym1__ <= nage; ++sym1__) {
        current_statement__ = 19;
        current_statement__ = 19;
        check_greater_or_equal(function__, "cf_prob[sym1__]",
                               cf_prob[(sym1__ - 1)], 0);}
      current_statement__ = 19;
      for (int sym1__ = 1; sym1__ <= nage; ++sym1__) {
        current_statement__ = 19;
        current_statement__ = 19;
        check_less_or_equal(function__, "cf_prob[sym1__]",
                            cf_prob[(sym1__ - 1)], 1);}
      current_statement__ = 22;
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        current_statement__ = 22;
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          current_statement__ = 22;
          current_statement__ = 22;
          check_greater_or_equal(function__, "P[sym1__, sym2__]",
                                 rvalue(P,
                                   cons_list(index_uni(sym1__),
                                     cons_list(index_uni(sym2__),
                                       nil_index_list())), "P"), 0);}}
      current_statement__ = 22;
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        current_statement__ = 22;
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          current_statement__ = 22;
          current_statement__ = 22;
          check_less_or_equal(function__, "P[sym1__, sym2__]",
                              rvalue(P,
                                cons_list(index_uni(sym1__),
                                  cons_list(index_uni(sym2__),
                                    nil_index_list())), "P"), 1);}}
      current_statement__ = 23;
      for (int sym1__ = 1; sym1__ <= nage; ++sym1__) {
        current_statement__ = 23;
        for (int sym2__ = 1; sym2__ <= nbias; ++sym2__) {
          current_statement__ = 23;
          current_statement__ = 23;
          check_greater_or_equal(function__, "prev_prob[sym1__, sym2__]",
                                 rvalue(prev_prob,
                                   cons_list(index_uni(sym1__),
                                     cons_list(index_uni(sym2__),
                                       nil_index_list())), "prev_prob"), 0);}
      }
      current_statement__ = 24;
      for (int sym1__ = 1; sym1__ <= nage; ++sym1__) {
        current_statement__ = 24;
        current_statement__ = 24;
        check_greater_or_equal(function__, "mort_prob[sym1__]",
                               mort_prob[(sym1__ - 1)], 0);}
      current_statement__ = 25;
      for (int sym1__ = 1; sym1__ <= cf_yr_1dim__; ++sym1__) {
        current_statement__ = 25;
        for (int sym2__ = 1; sym2__ <= cf_yr_2dim__; ++sym2__) {
          current_statement__ = 25;
          current_statement__ = 25;
          check_greater_or_equal(function__, "cf_yr[sym1__, sym2__]",
                                 rvalue(cf_yr,
                                   cons_list(index_uni(sym1__),
                                     cons_list(index_uni(sym2__),
                                       nil_index_list())), "cf_yr"), 0);}}
      current_statement__ = 26;
      for (int sym1__ = 1; sym1__ <= inc_yr_1dim__; ++sym1__) {
        current_statement__ = 26;
        for (int sym2__ = 1; sym2__ <= inc_yr_2dim__; ++sym2__) {
          current_statement__ = 26;
          for (int sym3__ = 1; sym3__ <= nbias; ++sym3__) {
            current_statement__ = 26;
            current_statement__ = 26;
            check_greater_or_equal(function__,
                                   "inc_yr[sym1__, sym2__, sym3__]",
                                   inc_yr[(sym1__ - 1)][(sym2__ - 1)][
                                   (sym3__ - 1)], 0);}}}
      current_statement__ = 28;
      current_statement__ = 28;
      check_greater_or_equal(function__, "lambda_cf_use", lambda_cf_use, 0);
      current_statement__ = 29;
      current_statement__ = 29;
      check_greater_or_equal(function__, "lambda_inc_use", lambda_inc_use, 0);
      current_statement__ = 30;
      current_statement__ = 30;
      check_greater_or_equal(function__, "lambda_rem_use", lambda_rem_use, 0);
      if (emit_transformed_parameters__) {
        for (int sym1__ = 1; sym1__ <= nage; ++sym1__) {
          vars__.emplace_back(cf[(sym1__ - 1)]);}
        for (int sym1__ = 1; sym1__ <= dcf_1dim__; ++sym1__) {
          vars__.emplace_back(dcf[(sym1__ - 1)]);}
        for (int sym1__ = 1; sym1__ <= nbias; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= nage; ++sym2__) {
            vars__.emplace_back(
              rvalue(inc,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(sym1__), nil_index_list())), "inc"));}}
        for (int sym1__ = 1; sym1__ <= nbias; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= nage; ++sym2__) {
            vars__.emplace_back(
              rvalue(inc_prob,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(sym1__), nil_index_list())),
                "inc_prob"));}}
        for (int sym1__ = 1; sym1__ <= nage; ++sym1__) {
          vars__.emplace_back(rem[(sym1__ - 1)]);}
        for (int sym1__ = 1; sym1__ <= rem_prob_1dim__; ++sym1__) {
          vars__.emplace_back(rem_prob[(sym1__ - 1)]);}
        for (int sym1__ = 1; sym1__ <= nage; ++sym1__) {
          vars__.emplace_back(cf_prob[(sym1__ - 1)]);}
        for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= nbias; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= state_probs_1dim__; ++sym3__) {
              vars__.emplace_back(
                state_probs[(sym3__ - 1)][(sym2__ - 1)][(sym1__ - 1)]);}}}
        for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
          vars__.emplace_back(tmp[(sym1__ - 1)]);}
        for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
            vars__.emplace_back(
              rvalue(P,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(sym1__), nil_index_list())), "P"));}}
        for (int sym1__ = 1; sym1__ <= nbias; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= nage; ++sym2__) {
            vars__.emplace_back(
              rvalue(prev_prob,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(sym1__), nil_index_list())),
                "prev_prob"));}}
        for (int sym1__ = 1; sym1__ <= nage; ++sym1__) {
          vars__.emplace_back(mort_prob[(sym1__ - 1)]);}
        for (int sym1__ = 1; sym1__ <= cf_yr_2dim__; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= cf_yr_1dim__; ++sym2__) {
            vars__.emplace_back(
              rvalue(cf_yr,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(sym1__), nil_index_list())), "cf_yr"));
          }}
        for (int sym1__ = 1; sym1__ <= nbias; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= inc_yr_2dim__; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= inc_yr_1dim__; ++sym3__) {
              vars__.emplace_back(
                inc_yr[(sym3__ - 1)][(sym2__ - 1)][(sym1__ - 1)]);}}}
        for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= nbias; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= state_probs_yr_2dim__; ++sym3__) {
              for (int sym4__ = 1; sym4__ <= state_probs_yr_1dim__; ++sym4__) {
                vars__.emplace_back(
                  state_probs_yr[(sym4__ - 1)][(sym3__ - 1)][(sym2__ - 1)][
                  (sym1__ - 1)]);}}}}
        vars__.emplace_back(lambda_cf_use);
        vars__.emplace_back(lambda_inc_use);
        vars__.emplace_back(lambda_rem_use);
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
      Eigen::Matrix<double, -1, 1> ll_mort;
      ll_mort = Eigen::Matrix<double, -1, 1>(nage);
      stan::math::fill(ll_mort, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, 1> ll_inc;
      ll_inc = Eigen::Matrix<double, -1, 1>(ll_inc_1dim__);
      stan::math::fill(ll_inc, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, 1> ll_prev;
      ll_prev = Eigen::Matrix<double, -1, 1>(ll_prev_1dim__);
      stan::math::fill(ll_prev, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, 1> ll_rem;
      ll_rem = Eigen::Matrix<double, -1, 1>(ll_rem_1dim__);
      stan::math::fill(ll_rem, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, 1> ll_overall;
      ll_overall = Eigen::Matrix<double, -1, 1>(ll_overall_1dim__);
      stan::math::fill(ll_overall, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 154;
      for (int a = 1; a <= nage; ++a) {
        current_statement__ = 146;
        assign(ll_mort, cons_list(index_uni(a), nil_index_list()),
          binomial_lpmf<false>(mort_num[(a - 1)], mort_denom[(a - 1)],
            mort_prob[(a - 1)]), "assigning variable ll_mort");
        current_statement__ = 148;
        if (inc_supplied) {
          current_statement__ = 147;
          assign(ll_inc, cons_list(index_uni(a), nil_index_list()),
            binomial_lpmf<false>(inc_num[(a - 1)], inc_denom[(a - 1)],
              rvalue(inc_prob, cons_list(index_uni(a), nil_index_list()),
                "inc_prob")), "assigning variable ll_inc");
        } 
        current_statement__ = 150;
        if (prev_supplied) {
          current_statement__ = 149;
          assign(ll_prev, cons_list(index_uni(a), nil_index_list()),
            binomial_lpmf<false>(prev_num[(a - 1)], prev_denom[(a - 1)],
              rvalue(prev_prob, cons_list(index_uni(a), nil_index_list()),
                "prev_prob")), "assigning variable ll_prev");
        } 
        current_statement__ = 152;
        if (remission) {
          current_statement__ = 151;
          assign(ll_rem, cons_list(index_uni(a), nil_index_list()),
            binomial_lpmf<false>(rem_num[(a - 1)], rem_denom[(a - 1)],
              rem_prob[(a - 1)]), "assigning variable ll_rem");
        } }
      current_statement__ = 155;
      assign(ll_overall, nil_index_list(),
        append_row(ll_mort, append_row(ll_inc, append_row(ll_prev, ll_rem))),
        "assigning variable ll_overall");
      for (int sym1__ = 1; sym1__ <= nage; ++sym1__) {
        vars__.emplace_back(ll_mort[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= ll_inc_1dim__; ++sym1__) {
        vars__.emplace_back(ll_inc[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= ll_prev_1dim__; ++sym1__) {
        vars__.emplace_back(ll_prev[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= ll_rem_1dim__; ++sym1__) {
        vars__.emplace_back(ll_rem[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= ll_overall_1dim__; ++sym1__) {
        vars__.emplace_back(ll_overall[(sym1__ - 1)]);}
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, stan::require_std_vector_t<VecVar>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void transform_inits_impl(const stan::io::var_context& context__,
                                   VecI& params_i__, VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.clear();
    vars__.reserve(num_params_r__);
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      Eigen::Matrix<double, -1, 1> inc_par;
      inc_par = Eigen::Matrix<double, -1, 1>(inc_par_1dim__);
      stan::math::fill(inc_par, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> inc_par_flat__;
        current_statement__ = 1;
        assign(inc_par_flat__, nil_index_list(), context__.vals_r("inc_par"),
          "assigning variable inc_par_flat__");
        current_statement__ = 1;
        pos__ = 1;
        current_statement__ = 1;
        for (int sym1__ = 1; sym1__ <= inc_par_1dim__; ++sym1__) {
          current_statement__ = 1;
          assign(inc_par, cons_list(index_uni(sym1__), nil_index_list()),
            inc_par_flat__[(pos__ - 1)], "assigning variable inc_par");
          current_statement__ = 1;
          pos__ = (pos__ + 1);}
      }
      Eigen::Matrix<double, -1, 1> inc_par_free__;
      inc_par_free__ = Eigen::Matrix<double, -1, 1>(inc_par_1dim__);
      stan::math::fill(inc_par_free__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 1;
      for (int sym1__ = 1; sym1__ <= inc_par_1dim__; ++sym1__) {
        current_statement__ = 1;
        assign(inc_par_free__,
          cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_free(inc_par[(sym1__ - 1)], 0),
          "assigning variable inc_par_free__");}
      Eigen::Matrix<double, -1, 1> cf_par;
      cf_par = Eigen::Matrix<double, -1, 1>(cf_par_1dim__);
      stan::math::fill(cf_par, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> cf_par_flat__;
        current_statement__ = 2;
        assign(cf_par_flat__, nil_index_list(), context__.vals_r("cf_par"),
          "assigning variable cf_par_flat__");
        current_statement__ = 2;
        pos__ = 1;
        current_statement__ = 2;
        for (int sym1__ = 1; sym1__ <= cf_par_1dim__; ++sym1__) {
          current_statement__ = 2;
          assign(cf_par, cons_list(index_uni(sym1__), nil_index_list()),
            cf_par_flat__[(pos__ - 1)], "assigning variable cf_par");
          current_statement__ = 2;
          pos__ = (pos__ + 1);}
      }
      Eigen::Matrix<double, -1, 1> cf_par_free__;
      cf_par_free__ = Eigen::Matrix<double, -1, 1>(cf_par_1dim__);
      stan::math::fill(cf_par_free__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 2;
      for (int sym1__ = 1; sym1__ <= cf_par_1dim__; ++sym1__) {
        current_statement__ = 2;
        assign(cf_par_free__, cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_free(cf_par[(sym1__ - 1)], 0),
          "assigning variable cf_par_free__");}
      Eigen::Matrix<double, -1, 1> rem_par;
      rem_par = Eigen::Matrix<double, -1, 1>(rem_par_1dim__);
      stan::math::fill(rem_par, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> rem_par_flat__;
        current_statement__ = 3;
        assign(rem_par_flat__, nil_index_list(), context__.vals_r("rem_par"),
          "assigning variable rem_par_flat__");
        current_statement__ = 3;
        pos__ = 1;
        current_statement__ = 3;
        for (int sym1__ = 1; sym1__ <= rem_par_1dim__; ++sym1__) {
          current_statement__ = 3;
          assign(rem_par, cons_list(index_uni(sym1__), nil_index_list()),
            rem_par_flat__[(pos__ - 1)], "assigning variable rem_par");
          current_statement__ = 3;
          pos__ = (pos__ + 1);}
      }
      Eigen::Matrix<double, -1, 1> rem_par_free__;
      rem_par_free__ = Eigen::Matrix<double, -1, 1>(rem_par_1dim__);
      stan::math::fill(rem_par_free__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 3;
      for (int sym1__ = 1; sym1__ <= rem_par_1dim__; ++sym1__) {
        current_statement__ = 3;
        assign(rem_par_free__,
          cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_free(rem_par[(sym1__ - 1)], 0),
          "assigning variable rem_par_free__");}
      Eigen::Matrix<double, -1, 1> beta;
      beta = Eigen::Matrix<double, -1, 1>(beta_1dim__);
      stan::math::fill(beta, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> beta_flat__;
        current_statement__ = 4;
        assign(beta_flat__, nil_index_list(), context__.vals_r("beta"),
          "assigning variable beta_flat__");
        current_statement__ = 4;
        pos__ = 1;
        current_statement__ = 4;
        for (int sym1__ = 1; sym1__ <= beta_1dim__; ++sym1__) {
          current_statement__ = 4;
          assign(beta, cons_list(index_uni(sym1__), nil_index_list()),
            beta_flat__[(pos__ - 1)], "assigning variable beta");
          current_statement__ = 4;
          pos__ = (pos__ + 1);}
      }
      Eigen::Matrix<double, -1, 1> lambda_cf;
      lambda_cf = Eigen::Matrix<double, -1, 1>(lambda_cf_1dim__);
      stan::math::fill(lambda_cf, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> lambda_cf_flat__;
        current_statement__ = 5;
        assign(lambda_cf_flat__, nil_index_list(),
          context__.vals_r("lambda_cf"),
          "assigning variable lambda_cf_flat__");
        current_statement__ = 5;
        pos__ = 1;
        current_statement__ = 5;
        for (int sym1__ = 1; sym1__ <= lambda_cf_1dim__; ++sym1__) {
          current_statement__ = 5;
          assign(lambda_cf, cons_list(index_uni(sym1__), nil_index_list()),
            lambda_cf_flat__[(pos__ - 1)], "assigning variable lambda_cf");
          current_statement__ = 5;
          pos__ = (pos__ + 1);}
      }
      Eigen::Matrix<double, -1, 1> lambda_cf_free__;
      lambda_cf_free__ = Eigen::Matrix<double, -1, 1>(lambda_cf_1dim__);
      stan::math::fill(lambda_cf_free__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 5;
      for (int sym1__ = 1; sym1__ <= lambda_cf_1dim__; ++sym1__) {
        current_statement__ = 5;
        assign(lambda_cf_free__,
          cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_free(lambda_cf[(sym1__ - 1)], 0),
          "assigning variable lambda_cf_free__");}
      Eigen::Matrix<double, -1, 1> lambda_inc;
      lambda_inc = Eigen::Matrix<double, -1, 1>(lambda_inc_1dim__);
      stan::math::fill(lambda_inc, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> lambda_inc_flat__;
        current_statement__ = 6;
        assign(lambda_inc_flat__, nil_index_list(),
          context__.vals_r("lambda_inc"),
          "assigning variable lambda_inc_flat__");
        current_statement__ = 6;
        pos__ = 1;
        current_statement__ = 6;
        for (int sym1__ = 1; sym1__ <= lambda_inc_1dim__; ++sym1__) {
          current_statement__ = 6;
          assign(lambda_inc, cons_list(index_uni(sym1__), nil_index_list()),
            lambda_inc_flat__[(pos__ - 1)], "assigning variable lambda_inc");
          current_statement__ = 6;
          pos__ = (pos__ + 1);}
      }
      Eigen::Matrix<double, -1, 1> lambda_inc_free__;
      lambda_inc_free__ = Eigen::Matrix<double, -1, 1>(lambda_inc_1dim__);
      stan::math::fill(lambda_inc_free__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 6;
      for (int sym1__ = 1; sym1__ <= lambda_inc_1dim__; ++sym1__) {
        current_statement__ = 6;
        assign(lambda_inc_free__,
          cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_free(lambda_inc[(sym1__ - 1)], 0),
          "assigning variable lambda_inc_free__");}
      Eigen::Matrix<double, -1, 1> beta_inc;
      beta_inc = Eigen::Matrix<double, -1, 1>(beta_inc_1dim__);
      stan::math::fill(beta_inc, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> beta_inc_flat__;
        current_statement__ = 7;
        assign(beta_inc_flat__, nil_index_list(),
          context__.vals_r("beta_inc"), "assigning variable beta_inc_flat__");
        current_statement__ = 7;
        pos__ = 1;
        current_statement__ = 7;
        for (int sym1__ = 1; sym1__ <= beta_inc_1dim__; ++sym1__) {
          current_statement__ = 7;
          assign(beta_inc, cons_list(index_uni(sym1__), nil_index_list()),
            beta_inc_flat__[(pos__ - 1)], "assigning variable beta_inc");
          current_statement__ = 7;
          pos__ = (pos__ + 1);}
      }
      Eigen::Matrix<double, -1, 1> lambda_rem;
      lambda_rem = Eigen::Matrix<double, -1, 1>(lambda_rem_1dim__);
      stan::math::fill(lambda_rem, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> lambda_rem_flat__;
        current_statement__ = 8;
        assign(lambda_rem_flat__, nil_index_list(),
          context__.vals_r("lambda_rem"),
          "assigning variable lambda_rem_flat__");
        current_statement__ = 8;
        pos__ = 1;
        current_statement__ = 8;
        for (int sym1__ = 1; sym1__ <= lambda_rem_1dim__; ++sym1__) {
          current_statement__ = 8;
          assign(lambda_rem, cons_list(index_uni(sym1__), nil_index_list()),
            lambda_rem_flat__[(pos__ - 1)], "assigning variable lambda_rem");
          current_statement__ = 8;
          pos__ = (pos__ + 1);}
      }
      Eigen::Matrix<double, -1, 1> lambda_rem_free__;
      lambda_rem_free__ = Eigen::Matrix<double, -1, 1>(lambda_rem_1dim__);
      stan::math::fill(lambda_rem_free__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 8;
      for (int sym1__ = 1; sym1__ <= lambda_rem_1dim__; ++sym1__) {
        current_statement__ = 8;
        assign(lambda_rem_free__,
          cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_free(lambda_rem[(sym1__ - 1)], 0),
          "assigning variable lambda_rem_free__");}
      Eigen::Matrix<double, -1, 1> beta_rem;
      beta_rem = Eigen::Matrix<double, -1, 1>(beta_rem_1dim__);
      stan::math::fill(beta_rem, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> beta_rem_flat__;
        current_statement__ = 9;
        assign(beta_rem_flat__, nil_index_list(),
          context__.vals_r("beta_rem"), "assigning variable beta_rem_flat__");
        current_statement__ = 9;
        pos__ = 1;
        current_statement__ = 9;
        for (int sym1__ = 1; sym1__ <= beta_rem_1dim__; ++sym1__) {
          current_statement__ = 9;
          assign(beta_rem, cons_list(index_uni(sym1__), nil_index_list()),
            beta_rem_flat__[(pos__ - 1)], "assigning variable beta_rem");
          current_statement__ = 9;
          pos__ = (pos__ + 1);}
      }
      Eigen::Matrix<double, -1, 1> prevzero;
      prevzero = Eigen::Matrix<double, -1, 1>(prev_zero);
      stan::math::fill(prevzero, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> prevzero_flat__;
        current_statement__ = 10;
        assign(prevzero_flat__, nil_index_list(),
          context__.vals_r("prevzero"), "assigning variable prevzero_flat__");
        current_statement__ = 10;
        pos__ = 1;
        current_statement__ = 10;
        for (int sym1__ = 1; sym1__ <= prev_zero; ++sym1__) {
          current_statement__ = 10;
          assign(prevzero, cons_list(index_uni(sym1__), nil_index_list()),
            prevzero_flat__[(pos__ - 1)], "assigning variable prevzero");
          current_statement__ = 10;
          pos__ = (pos__ + 1);}
      }
      Eigen::Matrix<double, -1, 1> prevzero_free__;
      prevzero_free__ = Eigen::Matrix<double, -1, 1>(prev_zero);
      stan::math::fill(prevzero_free__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 10;
      for (int sym1__ = 1; sym1__ <= prev_zero; ++sym1__) {
        current_statement__ = 10;
        assign(prevzero_free__,
          cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lub_free(prevzero[(sym1__ - 1)], 0, 1),
          "assigning variable prevzero_free__");}
      Eigen::Matrix<double, -1, 1> bias_loghr;
      bias_loghr = Eigen::Matrix<double, -1, 1>(bias_loghr_1dim__);
      stan::math::fill(bias_loghr, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> bias_loghr_flat__;
        current_statement__ = 11;
        assign(bias_loghr_flat__, nil_index_list(),
          context__.vals_r("bias_loghr"),
          "assigning variable bias_loghr_flat__");
        current_statement__ = 11;
        pos__ = 1;
        current_statement__ = 11;
        for (int sym1__ = 1; sym1__ <= bias_loghr_1dim__; ++sym1__) {
          current_statement__ = 11;
          assign(bias_loghr, cons_list(index_uni(sym1__), nil_index_list()),
            bias_loghr_flat__[(pos__ - 1)], "assigning variable bias_loghr");
          current_statement__ = 11;
          pos__ = (pos__ + 1);}
      }
      Eigen::Matrix<double, -1, 1> cfbase;
      cfbase = Eigen::Matrix<double, -1, 1>(cfbase_1dim__);
      stan::math::fill(cfbase, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> cfbase_flat__;
        current_statement__ = 12;
        assign(cfbase_flat__, nil_index_list(), context__.vals_r("cfbase"),
          "assigning variable cfbase_flat__");
        current_statement__ = 12;
        pos__ = 1;
        current_statement__ = 12;
        for (int sym1__ = 1; sym1__ <= cfbase_1dim__; ++sym1__) {
          current_statement__ = 12;
          assign(cfbase, cons_list(index_uni(sym1__), nil_index_list()),
            cfbase_flat__[(pos__ - 1)], "assigning variable cfbase");
          current_statement__ = 12;
          pos__ = (pos__ + 1);}
      }
      Eigen::Matrix<double, -1, 1> cfbase_free__;
      cfbase_free__ = Eigen::Matrix<double, -1, 1>(cfbase_1dim__);
      stan::math::fill(cfbase_free__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 12;
      for (int sym1__ = 1; sym1__ <= cfbase_1dim__; ++sym1__) {
        current_statement__ = 12;
        assign(cfbase_free__, cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_free(cfbase[(sym1__ - 1)], 0),
          "assigning variable cfbase_free__");}
      for (int sym1__ = 1; sym1__ <= inc_par_1dim__; ++sym1__) {
        vars__.emplace_back(inc_par_free__[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= cf_par_1dim__; ++sym1__) {
        vars__.emplace_back(cf_par_free__[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= rem_par_1dim__; ++sym1__) {
        vars__.emplace_back(rem_par_free__[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= beta_1dim__; ++sym1__) {
        vars__.emplace_back(beta[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= lambda_cf_1dim__; ++sym1__) {
        vars__.emplace_back(lambda_cf_free__[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= lambda_inc_1dim__; ++sym1__) {
        vars__.emplace_back(lambda_inc_free__[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= beta_inc_1dim__; ++sym1__) {
        vars__.emplace_back(beta_inc[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= lambda_rem_1dim__; ++sym1__) {
        vars__.emplace_back(lambda_rem_free__[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= beta_rem_1dim__; ++sym1__) {
        vars__.emplace_back(beta_rem[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= prev_zero; ++sym1__) {
        vars__.emplace_back(prevzero_free__[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= bias_loghr_1dim__; ++sym1__) {
        vars__.emplace_back(bias_loghr[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= cfbase_1dim__; ++sym1__) {
        vars__.emplace_back(cfbase_free__[(sym1__ - 1)]);}
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__.clear();
    names__.emplace_back("inc_par");
    names__.emplace_back("cf_par");
    names__.emplace_back("rem_par");
    names__.emplace_back("beta");
    names__.emplace_back("lambda_cf");
    names__.emplace_back("lambda_inc");
    names__.emplace_back("beta_inc");
    names__.emplace_back("lambda_rem");
    names__.emplace_back("beta_rem");
    names__.emplace_back("prevzero");
    names__.emplace_back("bias_loghr");
    names__.emplace_back("cfbase");
    names__.emplace_back("cf");
    names__.emplace_back("dcf");
    names__.emplace_back("inc");
    names__.emplace_back("inc_prob");
    names__.emplace_back("rem");
    names__.emplace_back("rem_prob");
    names__.emplace_back("cf_prob");
    names__.emplace_back("state_probs");
    names__.emplace_back("tmp");
    names__.emplace_back("P");
    names__.emplace_back("prev_prob");
    names__.emplace_back("mort_prob");
    names__.emplace_back("cf_yr");
    names__.emplace_back("inc_yr");
    names__.emplace_back("state_probs_yr");
    names__.emplace_back("lambda_cf_use");
    names__.emplace_back("lambda_inc_use");
    names__.emplace_back("lambda_rem_use");
    names__.emplace_back("ll_mort");
    names__.emplace_back("ll_inc");
    names__.emplace_back("ll_prev");
    names__.emplace_back("ll_rem");
    names__.emplace_back("ll_overall");
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    dimss__.clear();
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(inc_par_1dim__)
                                             });
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(cf_par_1dim__)
                                             });
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(rem_par_1dim__)
                                             });
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(beta_1dim__)});
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(lambda_cf_1dim__)
                                             });
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(lambda_inc_1dim__)
                                             });
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(beta_inc_1dim__)
                                             });
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(lambda_rem_1dim__)
                                             });
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(beta_rem_1dim__)
                                             });
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(prev_zero)});
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(bias_loghr_1dim__)
                                             });
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(cfbase_1dim__)
                                             });
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nage)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(dcf_1dim__)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nage),
                                             static_cast<size_t>(nbias)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nage),
                                             static_cast<size_t>(nbias)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nage)});
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(rem_prob_1dim__)
                                             });
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nage)});
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(state_probs_1dim__)
                                             , static_cast<size_t>(nbias),
                                             static_cast<size_t>(3)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(3)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(3),
                                             static_cast<size_t>(3)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nage),
                                             static_cast<size_t>(nbias)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nage)});
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(cf_yr_1dim__)
                                             ,
                                             static_cast<size_t>(cf_yr_2dim__)});
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(inc_yr_1dim__)
                                             ,
                                             static_cast<size_t>(inc_yr_2dim__)
                                             , static_cast<size_t>(nbias)});
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(state_probs_yr_1dim__)
                                             ,
                                             static_cast<size_t>(state_probs_yr_2dim__)
                                             , static_cast<size_t>(nbias),
                                             static_cast<size_t>(3)});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nage)});
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(ll_inc_1dim__)
                                             });
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(ll_prev_1dim__)
                                             });
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(ll_rem_1dim__)
                                             });
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(ll_overall_1dim__)
                                             });
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    for (int sym1__ = 1; sym1__ <= inc_par_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "inc_par" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= cf_par_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "cf_par" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= rem_par_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "rem_par" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= beta_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "beta" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= lambda_cf_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "lambda_cf" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= lambda_inc_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "lambda_inc" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= beta_inc_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "beta_inc" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= lambda_rem_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "lambda_rem" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= beta_rem_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "beta_rem" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= prev_zero; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "prevzero" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= bias_loghr_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "bias_loghr" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= cfbase_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "cfbase" + '.' + std::to_string(sym1__));
      }}
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= nage; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "cf" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= dcf_1dim__; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "dcf" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= nbias; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nage; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "inc" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= nbias; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nage; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "inc_prob" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= nage; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "rem" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= rem_prob_1dim__; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "rem_prob" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= nage; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "cf_prob" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nbias; ++sym2__) {
            {
              for (int sym3__ = 1; sym3__ <= state_probs_1dim__; ++sym3__) {
                {
                  param_names__.emplace_back(std::string() + "state_probs" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                }}
            }}
        }}
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "tmp" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "P" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= nbias; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nage; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "prev_prob" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= nage; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "mort_prob" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= cf_yr_2dim__; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= cf_yr_1dim__; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "cf_yr" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= nbias; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= inc_yr_2dim__; ++sym2__) {
            {
              for (int sym3__ = 1; sym3__ <= inc_yr_1dim__; ++sym3__) {
                {
                  param_names__.emplace_back(std::string() + "inc_yr" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                }}
            }}
        }}
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nbias; ++sym2__) {
            {
              for (int sym3__ = 1; sym3__ <= state_probs_yr_2dim__; ++sym3__) {
                {
                  for (int sym4__ = 1; sym4__ <= state_probs_yr_1dim__;
                       ++sym4__) {
                    {
                      param_names__.emplace_back(std::string() + "state_probs_yr" + '.' + std::to_string(sym4__) + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                    }}
                }}
            }}
        }}
      param_names__.emplace_back(std::string() + "lambda_cf_use");
      param_names__.emplace_back(std::string() + "lambda_inc_use");
      param_names__.emplace_back(std::string() + "lambda_rem_use");
    }
    
    if (emit_generated_quantities__) {
      for (int sym1__ = 1; sym1__ <= nage; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "ll_mort" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= ll_inc_1dim__; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "ll_inc" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= ll_prev_1dim__; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "ll_prev" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= ll_rem_1dim__; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "ll_rem" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= ll_overall_1dim__; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "ll_overall" + '.' + std::to_string(sym1__));
        }}
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    for (int sym1__ = 1; sym1__ <= inc_par_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "inc_par" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= cf_par_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "cf_par" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= rem_par_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "rem_par" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= beta_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "beta" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= lambda_cf_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "lambda_cf" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= lambda_inc_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "lambda_inc" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= beta_inc_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "beta_inc" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= lambda_rem_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "lambda_rem" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= beta_rem_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "beta_rem" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= prev_zero; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "prevzero" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= bias_loghr_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "bias_loghr" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= cfbase_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "cfbase" + '.' + std::to_string(sym1__));
      }}
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= nage; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "cf" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= dcf_1dim__; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "dcf" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= nbias; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nage; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "inc" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= nbias; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nage; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "inc_prob" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= nage; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "rem" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= rem_prob_1dim__; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "rem_prob" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= nage; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "cf_prob" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nbias; ++sym2__) {
            {
              for (int sym3__ = 1; sym3__ <= state_probs_1dim__; ++sym3__) {
                {
                  param_names__.emplace_back(std::string() + "state_probs" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                }}
            }}
        }}
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "tmp" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "P" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= nbias; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nage; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "prev_prob" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= nage; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "mort_prob" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= cf_yr_2dim__; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= cf_yr_1dim__; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "cf_yr" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= nbias; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= inc_yr_2dim__; ++sym2__) {
            {
              for (int sym3__ = 1; sym3__ <= inc_yr_1dim__; ++sym3__) {
                {
                  param_names__.emplace_back(std::string() + "inc_yr" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                }}
            }}
        }}
      for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nbias; ++sym2__) {
            {
              for (int sym3__ = 1; sym3__ <= state_probs_yr_2dim__; ++sym3__) {
                {
                  for (int sym4__ = 1; sym4__ <= state_probs_yr_1dim__;
                       ++sym4__) {
                    {
                      param_names__.emplace_back(std::string() + "state_probs_yr" + '.' + std::to_string(sym4__) + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                    }}
                }}
            }}
        }}
      param_names__.emplace_back(std::string() + "lambda_cf_use");
      param_names__.emplace_back(std::string() + "lambda_inc_use");
      param_names__.emplace_back(std::string() + "lambda_rem_use");
    }
    
    if (emit_generated_quantities__) {
      for (int sym1__ = 1; sym1__ <= nage; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "ll_mort" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= ll_inc_1dim__; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "ll_inc" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= ll_prev_1dim__; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "ll_prev" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= ll_rem_1dim__; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "ll_rem" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= ll_overall_1dim__; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "ll_overall" + '.' + std::to_string(sym1__));
        }}
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"inc_par\",\"type\":{\"name\":\"vector\",\"length\":" << inc_par_1dim__ << "},\"block\":\"parameters\"},{\"name\":\"cf_par\",\"type\":{\"name\":\"vector\",\"length\":" << cf_par_1dim__ << "},\"block\":\"parameters\"},{\"name\":\"rem_par\",\"type\":{\"name\":\"vector\",\"length\":" << rem_par_1dim__ << "},\"block\":\"parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"vector\",\"length\":" << beta_1dim__ << "},\"block\":\"parameters\"},{\"name\":\"lambda_cf\",\"type\":{\"name\":\"vector\",\"length\":" << lambda_cf_1dim__ << "},\"block\":\"parameters\"},{\"name\":\"lambda_inc\",\"type\":{\"name\":\"vector\",\"length\":" << lambda_inc_1dim__ << "},\"block\":\"parameters\"},{\"name\":\"beta_inc\",\"type\":{\"name\":\"vector\",\"length\":" << beta_inc_1dim__ << "},\"block\":\"parameters\"},{\"name\":\"lambda_rem\",\"type\":{\"name\":\"vector\",\"length\":" << lambda_rem_1dim__ << "},\"block\":\"parameters\"},{\"name\":\"beta_rem\",\"type\":{\"name\":\"vector\",\"length\":" << beta_rem_1dim__ << "},\"block\":\"parameters\"},{\"name\":\"prevzero\",\"type\":{\"name\":\"vector\",\"length\":" << prev_zero << "},\"block\":\"parameters\"},{\"name\":\"bias_loghr\",\"type\":{\"name\":\"vector\",\"length\":" << bias_loghr_1dim__ << "},\"block\":\"parameters\"},{\"name\":\"cfbase\",\"type\":{\"name\":\"vector\",\"length\":" << cfbase_1dim__ << "},\"block\":\"parameters\"},{\"name\":\"cf\",\"type\":{\"name\":\"vector\",\"length\":" << nage << "},\"block\":\"transformed_parameters\"},{\"name\":\"dcf\",\"type\":{\"name\":\"vector\",\"length\":" << dcf_1dim__ << "},\"block\":\"transformed_parameters\"},{\"name\":\"inc\",\"type\":{\"name\":\"matrix\",\"rows\":" << nage << ",\"cols\":" << nbias << "},\"block\":\"transformed_parameters\"},{\"name\":\"inc_prob\",\"type\":{\"name\":\"matrix\",\"rows\":" << nage << ",\"cols\":" << nbias << "},\"block\":\"transformed_parameters\"},{\"name\":\"rem\",\"type\":{\"name\":\"vector\",\"length\":" << nage << "},\"block\":\"transformed_parameters\"},{\"name\":\"rem_prob\",\"type\":{\"name\":\"vector\",\"length\":" << rem_prob_1dim__ << "},\"block\":\"transformed_parameters\"},{\"name\":\"cf_prob\",\"type\":{\"name\":\"vector\",\"length\":" << nage << "},\"block\":\"transformed_parameters\"},{\"name\":\"state_probs\",\"type\":{\"name\":\"array\",\"length\":" << state_probs_1dim__ << ",\"element_type\":{\"name\":\"array\",\"length\":" << nbias << ",\"element_type\":{\"name\":\"vector\",\"length\":" << 3 << "}}},\"block\":\"transformed_parameters\"},{\"name\":\"tmp\",\"type\":{\"name\":\"vector\",\"length\":" << 3 << "},\"block\":\"transformed_parameters\"},{\"name\":\"P\",\"type\":{\"name\":\"matrix\",\"rows\":" << 3 << ",\"cols\":" << 3 << "},\"block\":\"transformed_parameters\"},{\"name\":\"prev_prob\",\"type\":{\"name\":\"matrix\",\"rows\":" << nage << ",\"cols\":" << nbias << "},\"block\":\"transformed_parameters\"},{\"name\":\"mort_prob\",\"type\":{\"name\":\"array\",\"length\":" << nage << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"transformed_parameters\"},{\"name\":\"cf_yr\",\"type\":{\"name\":\"matrix\",\"rows\":" << cf_yr_1dim__ << ",\"cols\":" << cf_yr_2dim__ << "},\"block\":\"transformed_parameters\"},{\"name\":\"inc_yr\",\"type\":{\"name\":\"array\",\"length\":" << inc_yr_1dim__ << ",\"element_type\":{\"name\":\"array\",\"length\":" << inc_yr_2dim__ << ",\"element_type\":{\"name\":\"array\",\"length\":" << nbias << ",\"element_type\":{\"name\":\"real\"}}}},\"block\":\"transformed_parameters\"},{\"name\":\"state_probs_yr\",\"type\":{\"name\":\"array\",\"length\":" << state_probs_yr_1dim__ << ",\"element_type\":{\"name\":\"array\",\"length\":" << state_probs_yr_2dim__ << ",\"element_type\":{\"name\":\"array\",\"length\":" << nbias << ",\"element_type\":{\"name\":\"vector\",\"length\":" << 3 << "}}}},\"block\":\"transformed_parameters\"},{\"name\":\"lambda_cf_use\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"lambda_inc_use\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"lambda_rem_use\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"ll_mort\",\"type\":{\"name\":\"vector\",\"length\":" << nage << "},\"block\":\"generated_quantities\"},{\"name\":\"ll_inc\",\"type\":{\"name\":\"vector\",\"length\":" << ll_inc_1dim__ << "},\"block\":\"generated_quantities\"},{\"name\":\"ll_prev\",\"type\":{\"name\":\"vector\",\"length\":" << ll_prev_1dim__ << "},\"block\":\"generated_quantities\"},{\"name\":\"ll_rem\",\"type\":{\"name\":\"vector\",\"length\":" << ll_rem_1dim__ << "},\"block\":\"generated_quantities\"},{\"name\":\"ll_overall\",\"type\":{\"name\":\"vector\",\"length\":" << ll_overall_1dim__ << "},\"block\":\"generated_quantities\"}]";
    return s__.str();
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"inc_par\",\"type\":{\"name\":\"vector\",\"length\":" << inc_par_1dim__ << "},\"block\":\"parameters\"},{\"name\":\"cf_par\",\"type\":{\"name\":\"vector\",\"length\":" << cf_par_1dim__ << "},\"block\":\"parameters\"},{\"name\":\"rem_par\",\"type\":{\"name\":\"vector\",\"length\":" << rem_par_1dim__ << "},\"block\":\"parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"vector\",\"length\":" << beta_1dim__ << "},\"block\":\"parameters\"},{\"name\":\"lambda_cf\",\"type\":{\"name\":\"vector\",\"length\":" << lambda_cf_1dim__ << "},\"block\":\"parameters\"},{\"name\":\"lambda_inc\",\"type\":{\"name\":\"vector\",\"length\":" << lambda_inc_1dim__ << "},\"block\":\"parameters\"},{\"name\":\"beta_inc\",\"type\":{\"name\":\"vector\",\"length\":" << beta_inc_1dim__ << "},\"block\":\"parameters\"},{\"name\":\"lambda_rem\",\"type\":{\"name\":\"vector\",\"length\":" << lambda_rem_1dim__ << "},\"block\":\"parameters\"},{\"name\":\"beta_rem\",\"type\":{\"name\":\"vector\",\"length\":" << beta_rem_1dim__ << "},\"block\":\"parameters\"},{\"name\":\"prevzero\",\"type\":{\"name\":\"vector\",\"length\":" << prev_zero << "},\"block\":\"parameters\"},{\"name\":\"bias_loghr\",\"type\":{\"name\":\"vector\",\"length\":" << bias_loghr_1dim__ << "},\"block\":\"parameters\"},{\"name\":\"cfbase\",\"type\":{\"name\":\"vector\",\"length\":" << cfbase_1dim__ << "},\"block\":\"parameters\"},{\"name\":\"cf\",\"type\":{\"name\":\"vector\",\"length\":" << nage << "},\"block\":\"transformed_parameters\"},{\"name\":\"dcf\",\"type\":{\"name\":\"vector\",\"length\":" << dcf_1dim__ << "},\"block\":\"transformed_parameters\"},{\"name\":\"inc\",\"type\":{\"name\":\"matrix\",\"rows\":" << nage << ",\"cols\":" << nbias << "},\"block\":\"transformed_parameters\"},{\"name\":\"inc_prob\",\"type\":{\"name\":\"matrix\",\"rows\":" << nage << ",\"cols\":" << nbias << "},\"block\":\"transformed_parameters\"},{\"name\":\"rem\",\"type\":{\"name\":\"vector\",\"length\":" << nage << "},\"block\":\"transformed_parameters\"},{\"name\":\"rem_prob\",\"type\":{\"name\":\"vector\",\"length\":" << rem_prob_1dim__ << "},\"block\":\"transformed_parameters\"},{\"name\":\"cf_prob\",\"type\":{\"name\":\"vector\",\"length\":" << nage << "},\"block\":\"transformed_parameters\"},{\"name\":\"state_probs\",\"type\":{\"name\":\"array\",\"length\":" << state_probs_1dim__ << ",\"element_type\":{\"name\":\"array\",\"length\":" << nbias << ",\"element_type\":{\"name\":\"vector\",\"length\":" << 3 << "}}},\"block\":\"transformed_parameters\"},{\"name\":\"tmp\",\"type\":{\"name\":\"vector\",\"length\":" << 3 << "},\"block\":\"transformed_parameters\"},{\"name\":\"P\",\"type\":{\"name\":\"matrix\",\"rows\":" << 3 << ",\"cols\":" << 3 << "},\"block\":\"transformed_parameters\"},{\"name\":\"prev_prob\",\"type\":{\"name\":\"matrix\",\"rows\":" << nage << ",\"cols\":" << nbias << "},\"block\":\"transformed_parameters\"},{\"name\":\"mort_prob\",\"type\":{\"name\":\"array\",\"length\":" << nage << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"transformed_parameters\"},{\"name\":\"cf_yr\",\"type\":{\"name\":\"matrix\",\"rows\":" << cf_yr_1dim__ << ",\"cols\":" << cf_yr_2dim__ << "},\"block\":\"transformed_parameters\"},{\"name\":\"inc_yr\",\"type\":{\"name\":\"array\",\"length\":" << inc_yr_1dim__ << ",\"element_type\":{\"name\":\"array\",\"length\":" << inc_yr_2dim__ << ",\"element_type\":{\"name\":\"array\",\"length\":" << nbias << ",\"element_type\":{\"name\":\"real\"}}}},\"block\":\"transformed_parameters\"},{\"name\":\"state_probs_yr\",\"type\":{\"name\":\"array\",\"length\":" << state_probs_yr_1dim__ << ",\"element_type\":{\"name\":\"array\",\"length\":" << state_probs_yr_2dim__ << ",\"element_type\":{\"name\":\"array\",\"length\":" << nbias << ",\"element_type\":{\"name\":\"vector\",\"length\":" << 3 << "}}}},\"block\":\"transformed_parameters\"},{\"name\":\"lambda_cf_use\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"lambda_inc_use\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"lambda_rem_use\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"ll_mort\",\"type\":{\"name\":\"vector\",\"length\":" << nage << "},\"block\":\"generated_quantities\"},{\"name\":\"ll_inc\",\"type\":{\"name\":\"vector\",\"length\":" << ll_inc_1dim__ << "},\"block\":\"generated_quantities\"},{\"name\":\"ll_prev\",\"type\":{\"name\":\"vector\",\"length\":" << ll_prev_1dim__ << "},\"block\":\"generated_quantities\"},{\"name\":\"ll_rem\",\"type\":{\"name\":\"vector\",\"length\":" << ll_rem_1dim__ << "},\"block\":\"generated_quantities\"},{\"name\":\"ll_overall\",\"type\":{\"name\":\"vector\",\"length\":" << ll_overall_1dim__ << "},\"block\":\"generated_quantities\"}]";
    return s__.str();
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      std::vector<double> vars_vec(vars.size());
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i) {
        vars.coeffRef(i) = vars_vec[i];
      }
    }
    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }
    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }
    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }
  
    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits_impl(context, params_i, params_r_vec, pstream);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i) {
        params_r.coeffRef(i) = params_r_vec[i];
      }
    }
    inline void transform_inits(const stan::io::var_context& context,
                                std::vector<int>& params_i,
                                std::vector<double>& vars,
                                std::ostream* pstream = nullptr) const final {
      transform_inits_impl(context, params_i, vars, pstream);
    }        
};
}
using stan_model = model_disbayes_namespace::model_disbayes;
#ifndef USING_R
// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return model_disbayes_namespace::profiles__;
}
#endif
#endif
